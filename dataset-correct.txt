#' @keywords internal
`agent<-` <- function(x, value) {
  return_type <- NULL

  if ("dataset_bibentry" %in% names(attributes(x))) {
    dataset_bibentry <- get_bibentry(x)
    return_type <- "dataset"
  }

  if (inherits(x, "dublincore")) {
    dataset_bibentry <- x
    return_type <- "dublincore"
  }

  if (inherits(x, "datacite")) {
    dataset_bibentry <- x
    return_type <- "datacite"
  }

  assertthat::assert_that(
    !is.null(x),
    msg = "Error: agent(x)<- x must be a dataset_df, a dublincore or a datacite object."
  )


  assertthat::assert_that(all(inherits(value, "person")),
    msg = "Error: agent(x) <- value: value must be a vector of utils::persons() class."
  )

  creators <- ifelse(is.null(dataset_bibentry$author), ":tba", dataset_bibentry$author)
  publishers <- ifelse(is.null(dataset_bibentry$publisher), ":unas", dataset_bibentry$publisher)
  contributors <- ifelse(is.null(dataset_bibentry$contributor), ":unas", dataset_bibentry$contributor)

  get_creator <- function(x) {
    if (!is.null(x$role)) ifelse("cre" %in% x$role, TRUE, FALSE) else FALSE
  }

  get_author <- function(x) {
    if (!is.null(x$role)) ifelse("aut" %in% x$role, TRUE, FALSE) else FALSE
  }

  get_publisher <- function(x) {
    if (!is.null(x$role)) ifelse("pbl" %in% x$role, TRUE, FALSE) else FALSE
  }

  is_creator <- vapply(value, get_creator, logical(1))
  is_author <- vapply(value, get_author, logical(1))
  is_publisher <- vapply(value, get_publisher, logical(1))


  new_creators <- c(value[is_creator], value[is_author[!is_creator]])
  new_publishers <- c(value[is_publisher])
  new_contributors <- c(value[!value %in% c(creators, publishers)])

  creators <- ifelse(length(new_creators) > 0, new_creators, creators)
  publishers <- ifelse(length(new_publishers) > 0, new_publishers, publishers)
  contributors <- ifelse(length(new_creators) > 0,
    new_contributors,
    contributors
  )

  dataset_bibentry$author <- ifelse(length(new_creators) > 0,
    new_creators,
    dataset_bibentry[[1]]$author
  )
  dataset_bibentry$contributor <- contributors
  dataset_bibentry$publisher <- publishers

  if (return_type %in% c("datacite", "dublincore")) {
    dataset_bibentry
  } else if (return_type == "dataset") {
    attr(x, "dataset_bibentry") <- dataset_bibentry
    invisible(x)
  }
}

#' @keywords internal
agent <- function(x) {
  return_type <- NULL

  if (inherits(x, "dataset_df")) {
    dataset_bibentry <- get_bibentry(x)
    return_type <- "dataset"
  }

  if (inherits(x, "datacite")) {
    dataset_bibentry <- x
    creators <- ifelse(is.null(dataset_bibentry$author), ":tba", dataset_bibentry$author)
    publishers <- ifelse(is.null(dataset_bibentry$publisher), ":unas", dataset_bibentry$publisher)
    contributors <- ifelse(is.null(dataset_bibentry$contributor), ":unas", dataset_bibentry$contributor)
    return_type <- "datacite"
  }

  if (inherits(x, "dublincore")) {
    dataset_bibentry <- x
    creators <- ifelse(is.null(dataset_bibentry$author), ":tba", dataset_bibentry$author)
    publishers <- ifelse(is.null(dataset_bibentry$publisher), ":unas", dataset_bibentry$publisher)
    contributors <- ifelse(is.null(dataset_bibentry$contributor), ":unas", dataset_bibentry$contributor)

    return_type <- "dublincore"
  }

  if (all(inherits(x, "person"))) {
    contributors <- x
    publishers <- x
    creators <- x
    return_type <- "persons_vector"
  }

  assertthat::assert_that(
    any(return_type %in% c("dataset", "datacite", "dublincore", "persons_vector")),
    msg = "Error: agent(x)<- x must be a dataset_df, a vector of persons, a dublincore or datacite object."
  )

  get_creator <- function(x) {
    if (!is.null(x$role)) ifelse("cre" %in% x$role, TRUE, FALSE) else FALSE
  }

  get_author <- function(x) {
    if (!is.null(x$role)) ifelse("aut" %in% x$role, TRUE, FALSE) else FALSE
  }

  get_contributor <- function(x) {
    if (!is.null(x$role)) ifelse("ctb" %in% x$role, TRUE, FALSE) else FALSE
  }

  get_publisher <- function(x) {
    if (!is.null(x$role)) ifelse("pbl" %in% x$role, TRUE, FALSE) else FALSE
  }

  is_creator <- vapply(creators, get_creator, logical(1))
  is_author <- vapply(creators, get_author, logical(1))
  is_publisher <- vapply(creators, get_publisher, logical(1))
  is_contributor <- vapply(creators, get_contributor, logical(1))

  new_creators <- c(creators[is_creator], creators[is_author[!is_creator]])
  new_contributors <- c(contributors[!contributors %in% c(creators, publishers)])
  new_publishers <- publishers[is_publisher]
  new_contributors <- contributors[is_contributor]

  creators <- if (length(new_creators) > 0) creators <- new_creators
  contributors <- if (length(new_contributors) > 0) contributors <- new_contributors
  publishers <- if (length(new_publishers) > 0) publishers <- new_publishers

  list(
    creators = creators,
    contributors = contributors,
    publishers = publishers
  )
}
#' Coerce a defined vector to character
#'
#' `as_character()` is the recommended method to convert a
#' [`defined()`][defined] vector to a character type. It is metadata-aware and
#' ensures that the underlying data is character before coercion.
#'
#' If `preserve_attributes = TRUE`, the returned character vector retains
#' semantic metadata such as `unit`, `concept`, and `namespace`, though the
#' `"defined"` class itself is removed. If `preserve_attributes = FALSE`
#' (default), a plain character vector is returned with all attributes stripped.
#'
#' For numeric-based `defined` vectors, `as_character()` throws an informative
#' error to avoid accidental coercion of non-character data.
#'
#' Note: `as.character()` (base R) is supported but simply returns the raw
#' values, and does not preserve or warn about metadata loss.
#'
#' @param x A vector created with [defined()].
#' @param preserve_attributes Logical. If `TRUE`, retains `unit`, `concept`, and
#'   `namespace` attributes. Defaults to `FALSE`.
#' @param ... Reserved for future use.
#'
#' @return A character vector.
#'
#' @examples
#' # Recommended use
#' fruits <- defined(c("apple", "avocado", "kiwi"), label = "Fruit", unit = "kg")
#' as_character(fruits, preserve_attributes = TRUE)
#'
#' # Strip metadata
#' as_character(fruits, preserve_attributes = FALSE)
#'
#' # Equivalent base R fallback
#' as.character(fruits)
#'
#' @seealso [strip_defined()], [as_numeric()]
#' @export
as_character <- function(x, ...) {
  UseMethod("as_character", x)
}

#' @rdname as_character
#' @importFrom vctrs vec_data
#' @export
as_character.haven_labelled_defined <- function(
    x,
    preserve_attributes = FALSE,
    ...) {
  base <- vctrs::vec_data(x)

  tmp <- as.character(base)

  if (preserve_attributes) {
    attr(tmp, "unit") <- attr(x, "unit")
    attr(tmp, "concept") <- attr(x, "concept")
    attr(tmp, "namespace") <- attr(x, "namespace")
  }

  tmp
}

#' @rdname as_character
#' @description Base R's `as.character()` method applied to `defined` vectors
#' simply strips the class and returns the values as a plain character vector.
#' This is equivalent to calling [as_character()] with `preserve_attributes =
#' FALSE`.
#'
#' @export
as.character.haven_labelled_defined <- function(x, ...) {
  unclass(vctrs::vec_data(x))
}
#' @rdname datacite
#' @param x A dataset object created with [dataset_df()].
#' @param type A DataCite 4.4 metadata can be returned as:
#'   `"list"`, `"dataset_df"`, `"bibentry"` (default), or `"ntriples"`.
#' @param ... Optional parameters to add to a `datacite` object.
#'   For example, `author = person("Jane", "Doe")` adds an author if
#'   `type = "dataset_df"`.
#' @return `as_datacite(x, type)` returns the DataCite bibliographical metadata
#'   of `x` either as a list, a bibentry object, an N-Triples text serialisation
#'   or a dataset_df object.
#' @export
as_datacite <- function(x, type = "bibentry", ...) {
  citation_author <- person(NULL, NULL)

  is_person <- function(p) inherits(p, "person")

  arguments <- list(...)
  if (!is.null(arguments$author)) {
    if (is_person(arguments$author)) {
      citation_author <- arguments$author
    } else {
      stop("as_datacite(x, ..., author = ): author must be created with utils::person().")
    }
  }

  if (!type %in% c("bibentry", "list", "dataset_df", "ntriples")) {
    warning(paste0(
      "as_datacite(ds, type=...) type cannot be ",
      type, ". Reverting to 'bibentry'."
    ))
    type <- "bibentry"
  }

  ds_bibentry <- get_bibentry(x)
  Title <- ds_bibentry$title
  Creator <- ds_bibentry$author

  if (!is_person(Creator)) {
    stop('attr(x, "dataset_bibentry")$author is not a person object.')
  }

  # Date / Year fallback
  if (!is.null(ds_bibentry$year)) {
    if (is.null(ds_bibentry$dataset_date)) {
      Date <- as.character(ds_bibentry$year)
    } else {
      Date <- as.character(ds_bibentry$date)
    }
    PublicationYear <- as.character(ds_bibentry$year)
  } else if (!is.null(ds_bibentry$date)) {
    Date <- as.character(ds_bibentry$date)
    PublicationYear <- substr(Date, 1, 4)
  } else {
    Date <- ":tba"
    PublicationYear <- ":unas"
  }

  Publisher <- ifelse(is.null(ds_bibentry$publisher), "", as.character(ds_bibentry$publisher))
  Identifier <- ifelse(is.null(ds_bibentry$identifier), ":tba", as.character(ds_bibentry$identifier))
  Version <- ifelse(is.null(ds_bibentry$version), ":unas", as.character(ds_bibentry$version))
  Description <- ifelse(is.null(ds_bibentry$description), ":unas", as.character(ds_bibentry$description))
  Language <- ifelse(is.null(ds_bibentry$language), ":unas", as.character(ds_bibentry$language))
  Format <- ifelse(is.null(ds_bibentry$format), "application/r-rds", as.character(ds_bibentry$format))
  AlternateIdentifier <- ifelse(is.null(ds_bibentry$alternateidentifier), ":unas", ds_bibentry$alternateidentifier)
  RelatedIdentifier <- ifelse(is.null(ds_bibentry$relatedidentifier), ":unas", ds_bibentry$relatedidentifier)
  Rights <- ifelse(is.null(ds_bibentry$rights), ":tba", as.character(ds_bibentry$rights))
  Geolocation <- ifelse(is.null(ds_bibentry$geolocation), ":unas", as.character(ds_bibentry$geolocation))
  FundingReference <- ifelse(is.null(ds_bibentry$fundingreference), ":unas", as.character(ds_bibentry$fundingreference))

  # Contributors — check attribute if available
  Contributor <- if (!is.null(attr(ds_bibentry, "contributor"))) {
    attr(ds_bibentry, "contributor")
  } else if (!is.null(ds_bibentry$contributor)) {
    ds_bibentry$contributor
  } else {
    ""
  }

  # Subject handling (always structured or NULL)
  if (is.null(ds_bibentry$subject)) {
    Subject <- NULL
  } else if (is.subject(ds_bibentry$subject)) {
    Subject <- ds_bibentry$subject
  } else if (is.character(ds_bibentry$subject)) {
    Subject <- new_Subject(term = ds_bibentry$subject)
  } else {
    stop("Unsupported subject type in dataset_bibentry$subject")
  }

  if (type == "bibentry") {
    new_datacite(
      Title = Title,
      Creator = Creator,
      Identifier = Identifier,
      Publisher = Publisher,
      PublicationYear = PublicationYear,
      Subject = Subject,
      Type = "Dataset",
      Contributor = Contributor,
      Date = Date,
      Language = Language,
      AlternateIdentifier = AlternateIdentifier,
      RelatedIdentifier = RelatedIdentifier,
      Format = Format,
      Version = Version,
      Rights = Rights,
      Description = Description,
      Geolocation = Geolocation,
      FundingReference = FundingReference
    )
  } else if (type == "list") {
    if (identical(Contributor, "")) Contributor <- NULL
    if (identical(Subject, "")) Subject <- NULL

    list(
      Title = Title,
      Creator = Creator,
      Identifier = Identifier,
      Publisher = Publisher,
      PublicationYear = PublicationYear,
      Subject = Subject,
      Type = "Dataset",
      Contributor = Contributor,
      Date = Date,
      Language = Language,
      AlternateIdentifier = AlternateIdentifier,
      RelatedIdentifier = RelatedIdentifier,
      Format = Format,
      Version = Version,
      Rights = Rights,
      Description = Description,
      Geolocation = Geolocation,
      FundingReference = FundingReference
    )
  } else if (type == "dataset_df") {
    # Flatten multi-length values to single strings
    collapse_if_needed <- function(x) {
      if (length(x) > 1) paste(as.character(x), collapse = "; ") else x
    }

    flatten_subject <- function(s) {
      if (is.null(s)) {
        return("")
      }
      if (is.subject(s)) {
        # Use only the term for dataset_df export
        return(s$term)
      }
      as.character(s)
    }

    dataset_df(
      data.frame(
        Title = collapse_if_needed(Title),
        Creator = paste(
          vapply(Creator, function(p) p$family, character(1)),
          collapse = "; "
        ),
        Identifier = collapse_if_needed(Identifier),
        Publisher = collapse_if_needed(Publisher),
        PublicationYear = collapse_if_needed(PublicationYear),
        Subject = collapse_if_needed(flatten_subject(Subject)),
        Type = "Dataset",
        Contributor = if (is.null(Contributor)) {
          ":unas"
        } else {
          collapse_if_needed(as.character(Contributor))
        },
        Date = collapse_if_needed(Date),
        Language = collapse_if_needed(Language),
        AlternateIdentifier = collapse_if_needed(AlternateIdentifier),
        RelatedIdentifier = collapse_if_needed(RelatedIdentifier),
        Format = collapse_if_needed(Format),
        Version = collapse_if_needed(Version),
        Rights = collapse_if_needed(Rights),
        Description = collapse_if_needed(Description),
        Geolocation = collapse_if_needed(Geolocation),
        FundingReference = collapse_if_needed(FundingReference)
      ),
      dataset_bibentry = datacite(
        Title = paste0("The DataCite metadata of `", collapse_if_needed(Title), "`"),
        Creator = Creator,
        Identifier = collapse_if_needed(Identifier),
        Date = collapse_if_needed(Date)
      )
    )
  } else if (type == "ntriples") {
    dataset_id <- if (is.null(Identifier) || Identifier == ":tba") {
      "http://example.com/dataset_tba/"
    } else {
      Identifier
    }

    dc_list <- list(
      title = Title,
      creator = paste(vapply(Creator, function(p) p$family, character(1)), collapse = "; "),
      identifier = Identifier,
      publisher = Publisher,
      publicationyear = PublicationYear,
      subject = Subject,
      type = "http://purl.org/dc/dcmitype/Dataset",
      contributor = Contributor,
      date = Date,
      language = Language,
      alternateidentifier = AlternateIdentifier,
      relatedidentifier = RelatedIdentifier,
      format = Format,
      version = Version,
      rights = Rights,
      description = Description,
      geolocation = Geolocation,
      fundingreference = FundingReference
    )

    datacite_to_triples(dc_list, dataset_id = dataset_id)
  }
}
#' @rdname dublincore
#'
#' @param type Output format. One of `"bibentry"`, `"dataset_df"`, `"list"`, or
#'   `"ntriples"`. See Details.
#' @param ... Optional fields to attach to the `dublincore` object.
#'   For example, `author = person("Jane", "Doe")` adds an author to the
#'   citation if `type = "dataset_df"`.
#'
#' @export

as_dublincore <- function(x, type = "bibentry", ...) {
  citation_author <- person(NULL, NULL)

  is_person <- function(p) ifelse(inherits(p, "person"), TRUE, FALSE)

  arguments <- list(...)

  if (!is.null(arguments$author)) {
    if (is_person(arguments$author)) {
      citation_author <- arguments$author
    } else {
      stop("as_dublincore(x, ..., author = ): author must be created with utils::person().")
    }
  }

  if (!type %in% c("bibentry", "list", "dataset_df", "ntriples")) {
    warning(paste0(
      "as_dublincore(ds, type=...) type cannot be ",
      type, ". Reverting to 'bibentry'."
    ))
    type <- "bibentry"
  }

  dataset_bibentry <- get_bibentry(x)
  dataset_title <- dataset_bibentry$title
  dataset_creator <- dataset_bibentry$author

  if (!is_person(dataset_creator)) {
    stop('attr(x, "dataset_bibentry")$author is not a person object.')
  }

  if (!is.null(dataset_bibentry$year)) {
    if (is.null(dataset_bibentry$dataset_date)) {
      dataset_date <- as.character(dataset_bibentry$year)
    } else {
      dataset_date <- as.character(dataset_bibentry$date)
    }
  } else if (!is.null(dataset_bibentry$date)) {
    dataset_date <- dataset_bibentry$date
  } else {
    dataset_date <- ":tba"
  }

  dataset_relation <- ifelse(
    is.null(dataset_bibentry$relation), ":unas", as.character(dataset_bibentry$relation)
  )
  dataset_identifier <- ifelse(
    is.null(dataset_bibentry$identifier), ":tba", as.character(dataset_bibentry$identifier)
  )
  dataset_version <- ifelse(
    is.null(dataset_bibentry$version), ":unas", as.character(dataset_bibentry$version)
  )
  dataset_description <- ifelse(
    is.null(dataset_bibentry$description), ":unas", as.character(dataset_bibentry$description)
  )
  dataset_language <- ifelse(
    is.null(dataset_bibentry$language), ":unas", as.character(dataset_bibentry$language)
  )
  dataset_format <- ifelse(
    is.null(dataset_bibentry$format), "application/r-rds", as.character(dataset_bibentry$format)
  )
  dataset_rights <- ifelse(
    is.null(dataset_bibentry$rights), ":tba", as.character(dataset_bibentry$rights)
  )
  dataset_coverage <- ifelse(
    is.null(dataset_bibentry$coverage), ":unas", as.character(dataset_bibentry$coverage)
  )
  datasource <- ifelse(
    is.null(dataset_bibentry$datasource), ":unas", as.character(dataset_bibentry$datasource)
  )
  dataset_contributor <- ifelse(
    is.null(dataset_bibentry$contributor), "", as.character(dataset_bibentry$contributor)
  )
  dataset_subject <- ifelse(
    is.null(dataset_bibentry$subject), "", as.character(dataset_bibentry$subject)
  )
  dataset_publisher <- ifelse(
    is.null(dataset_bibentry$publisher), "", as.character(dataset_bibentry$publisher)
  )

  properties <- c(
    length(dataset_title),
    length(as.character(dataset_creator)),
    length(dataset_identifier),
    length(dataset_publisher),
    length(dataset_subject),
    length("DCMITYPE:Dataset"),
    length(dataset_contributor),
    length(dataset_date),
    length(dataset_language),
    length(dataset_relation),
    length(dataset_format),
    length(dataset_rights),
    length(datasource),
    length(dataset_description),
    length(dataset_coverage)
  )

  if (type == "bibentry") {
    new_dublincore(
      title = dataset_title,
      creator = dataset_creator,
      identifier = dataset_identifier,
      publisher = dataset_publisher,
      subject = dataset_subject,
      type = "DCMITYPE:Dataset",
      contributor = dataset_contributor,
      dataset_date = dataset_date,
      language = dataset_language,
      relation = dataset_relation,
      dataset_format = dataset_format,
      rights = dataset_rights,
      datasource = datasource,
      description = dataset_description,
      coverage = dataset_coverage
    )
  } else if (type == "list") {
    if (dataset_contributor == "") dataset_contributor <- NULL
    if (dataset_subject == "") dataset_subject <- NULL

    if (is.null(attr(dataset_bibentry, "contributor"))) {
      dataset_contributor <- ""
    } else {
      dataset_contributor <- attr(dataset_bibentry, "contributor")
    }

    list(
      title = dataset_title,
      creator = dataset_creator,
      identifier = dataset_identifier,
      publisher = dataset_publisher,
      subject = dataset_subject,
      type = "DCMITYPE:Dataset",
      contributor = dataset_contributor,
      date = dataset_date,
      language = dataset_language,
      relation = dataset_relation,
      dataset_format = dataset_format,
      rights = dataset_rights,
      datasource = datasource,
      description = dataset_description,
      coverage = dataset_coverage
    )
  } else if (type == "dataset_df") {
    assertthat::assert_that(
      all(properties == 1),
      msg = "In as_dublincore(), not all properties have length 1 and cannot be exported to dataset_df."
    )
    dataset_df(
      data.frame(
        title = dataset_title,
        creator = as.character(dataset_creator),
        identifier = dataset_identifier,
        publisher = dataset_publisher,
        subject = dataset_subject,
        type = "DCMITYPE:Dataset",
        contributor = dataset_contributor,
        date = dataset_date,
        language = dataset_language,
        relation = dataset_relation,
        dataset_format = dataset_format,
        rights = dataset_rights,
        datasource = datasource,
        description = dataset_description,
        coverage = dataset_coverage
      ),
      reference = list(
        title = paste0(
          "The Dublin Core Metadata of `",
          dataset_bibentry$title, "'"
        ),
        author = citation_author,
        year = substr(as.character(Sys.Date()), 1, 4)
      )
    )
  } else if (type == "ntriples") {
    dataset_id <- if (is.null(dataset_identifier) ||
      dataset_identifier == ":tba") {
      "http://example.com/dataset_tba/"
    } else {
      dataset_identifier
    }


    dataset_contributor <- attr(dataset_bibentry, "contributor")

    # Create full DC metadata list and delegate filtering/serialization
    dclist <- list(
      title       = dataset_title,
      creator     = dataset_creator,
      identifier  = dataset_identifier,
      publisher   = dataset_publisher,
      subject     = dataset_subject,
      type        = "http://purl.org/dc/dcmitype/Dataset",
      contributor = dataset_contributor,
      date        = dataset_date,
      language    = dataset_language,
      relation    = dataset_relation,
      format      = dataset_format,
      rights      = dataset_rights,
      datasource  = datasource,
      description = dataset_description,
      coverage    = dataset_coverage
    )

    return(dublincore_to_triples(
      dclist = dclist,
      dataset_id = dataset_id
    ))
  }
}
#' Coerce a defined vector to a factor
#'
#' Converts a [`defined()`][defined] vector with value labels into a
#' factor using [haven::as_factor()]. This allows categorical `defined`
#' vectors to behave like standard factors in models and plotting.
#'
#' @param x A vector created with [defined()].
#' @param ... Reserved for future extensions; not used.
#'
#' @return A factor vector with levels derived from the value labels.
#'
#' @examples
#' sex <- defined(
#'   c(0, 1, 1, 0),
#'   label = "Sex",
#'   labels = c("Female" = 0, "Male" = 1)
#' )
#' as_factor(sex)
#'
#' @export
as_factor <- function(x, ...) {
  UseMethod("as_factor")
}

#' @export
#' @importFrom haven as_factor labelled
#' @importFrom vctrs vec_data
as_factor.haven_labelled_defined <- function(x, ...) {
  haven::as_factor(
    haven::labelled(
      vctrs::vec_data(x),
      labels = attr(x, "labels")
    ),
    ...
  )
}
#' Coerce a defined vector to numeric
#'
#' `as_numeric()` is the recommended method to convert a [`defined()`][defined]
#' vector to a numeric vector. It ensures the underlying data is numeric and can
#' optionally preserve semantic metadata.
#'
#' If `preserve_attributes = TRUE`, the returned vector retains the `unit`,
#' `concept`, and `namespace` attributes, but is no longer of class `"defined"`.
#' If `FALSE` (default), a base numeric vector is returned without metadata.
#'
#' For character-based `defined` vectors, an error is thrown to avoid invalid
#' coercion.
#'
#' @param x A vector created with [defined()].
#' @param preserve_attributes Logical. Whether to keep metadata attributes.
#'   Defaults to `FALSE`.
#' @param ... Reserved for future use.
#'
#' @return A numeric vector (either bare or with metadata, depending on the
#'   `preserve_attributes` argument).
#'
#' @seealso [as.character()], [strip_defined()]
#'
#' @examples
#' gdp <- defined(c(3897L, 7365L), label = "GDP", unit = "million dollars")
#'
#' # Drop all metadata
#' as_numeric(gdp)
#'
#' # Preserve unit and concept
#' as_numeric(gdp, preserve_attributes = TRUE)
#'
#' # Equivalence to base coercion (without metadata)
#' as.numeric(gdp)
#'
#' # Metadata-aware variant preferred in pipelines
#' attr(as_numeric(gdp, TRUE), "unit")
#' @export
as_numeric <- function(x, ...) {
  UseMethod("as_numeric", x)
}

#' @export
vec_cast.double.haven_labelled_defined <- function(x, to, ...) {
  vctrs::vec_data(x)
}


#' @export
#' @rdname as_numeric
#' @importFrom vctrs vec_data
as_numeric.haven_labelled_defined <- function(x,
                                              preserve_attributes = FALSE,
                                              ...) {
  if (!is.numeric(vctrs::vec_data(x))) {
    stop("as_numeric(): underlying data is not numeric.")
  }

  if (preserve_attributes) {
    strip_defined(x)
  } else {
    vctrs::vec_data(x)
  }
}

#' @rdname as_numeric
#' @exportS3Method as.numeric haven_labelled_defined
#' @description
#' Base R's `as.numeric()` does not support custom classes like `defined()`.
#' This method drops all metadata and class information, returning a plain
#' numeric vector. It is equivalent to `as_numeric(x, preserve_attributes = FALSE)`.
as.numeric.haven_labelled_defined <- function(x, ...) {
  unclass(vctrs::vec_data(x))
}

#' @title Cast defined vector to base numeric (double)
#'
#' @description
#' S3 method for [`vctrs::vec_cast()`] that converts a
#' `haven_labelled_defined` vector (created by [defined()]) to a base
#' `numeric` (double) vector, dropping all semantic metadata.
#'
#' @param x `haven_labelled_defined` vector (created by [defined()]).
#' @param to Target type (must be `double()`).
#' @param ... Ignored; reserved for future use.
#'
#' @return A plain numeric (double) vector.
#'
#' @examples
#' x <- defined(c(10, 20), unit = "kg")
#' vctrs::vec_cast(x, double())
#' as.numeric(x)
#' @export
#' @method vec_cast.double haven_labelled_defined
#' @importFrom vctrs vec_cast vec_data
vec_cast.double.haven_labelled_defined <- function(x, to, ...) {
  vctrs::vec_data(x)
}
#' Create a Modern Metadata Object Compatible with bibentry
#'
#' Constructs a [utils::bibentry()] object extended with Dublin Core and
#' DataCite-compatible fields. This unified structure supports use with
#' functions such as [dublincore()] and [datacite()], and is the internal
#' format for storing rich metadata with datasets.
#'
#' @param title A character string specifying the dataset title.
#' @param author A [utils::person()] or list/vector of person objects. Mapped to
#'   `creator` in DataCite and DCMI.
#' @param contributor Optional list or vector of [utils::person()] objects.
#'   Contributor roles are merged if duplicated.
#' @param publisher A character string or [utils::person()] representing the
#'   publishing entity.
#' @param year Publication year. Automatically derived from `date` if not
#'   provided explicitly.
#' @param date A [Date] object or character string in ISO format.
#' @param identifier A persistent identifier (e.g., DOI or URL).
#' @param subject Optional keyword, tag, or controlled vocabulary term.
#' @param ... Additional fields such as `language`, `format`, `rights`, or
#'   `description`.
#'
#' @return
#' An object of class `"bibrecord"` and `"bibentry"`, suitable for citation and
#' embedding in metadata-aware structures such as [dataset_df()].
#'
#' @examples
#' bibrecord(
#'   title = "Gross domestic product, volumes",
#'   author = person("Eurosat"),
#'   publisher = person("Eurostat"),
#'   identifier = "https://doi.org/10.2908/TEINA011",
#'   date = as.Date("2025-05-20")
#' )
#'
#' @seealso
#' Learn more in the vignette:
#' [`bibrecord`](https://dataset.dataobservatory.eu/articles/bibrecord.html)
#' @importFrom utils bibentry
#' @family bibrecord functions
#' @export
bibrecord <- function(
    title,
    author,
    contributor = NULL,
    publisher = NULL,
    year = NULL,
    date = Sys.Date(),
    identifier = NULL,
    subject = NULL,
    ...) {
  stopifnot(inherits(author, "person") ||
    all(vapply(author, inherits, logical(1), "person")))

  # Normalize author roles and ensure vector of class "person"
  author <- normalize_roles(as.list(author))
  author <- do.call("c", author)

  # Normalize contributor if present
  if (!is.null(contributor)) {
    if (inherits(contributor, "person")) {
      contributor <- list(contributor)
    }
    contributor <- normalize_roles(as.list(contributor))
    contributor <- do.call("c", contributor)
  }

  # Infer year from date if missing
  year <- year %||% substr(as.character(date), 1, 4)

  meta <- bibentry(
    bibtype = "Misc",
    title = title,
    author = author,
    year = year,
    date = as.character(date),
    identifier = identifier,
    publisher = publisher,
    subject = subject,
    ...
  )

  if (!is.null(contributor)) {
    attr(meta, "contributor") <- contributor
  }

  class(meta) <- c("bibrecord", class(meta))
  meta
}

#' @keywords internal
`%||%` <- function(a, b) {
  if (!is.null(a)) a else b
}

#' @export
print.bibrecord <- function(x, ...) {
  NextMethod("print")

  contributors <- attr(x, "contributor")
  if (!is.null(contributors)) {
    cat("\nContributors:\n")
    cat(fix_contributor(contributors), "\n")
  }

  invisible(x)
}
#' @title Bind strictly defined rows
#' @description Add rows of dataset \code{y} to dataset \code{x}, validating all
#'   semantic metadata. Metadata (labels, units, concept definitions,
#'   namespaces) must match exactly. Additional dataset-level metadata such as
#'   title and creator can be overridden using \code{...}.
#'
#' @details This function combines two semantically enriched datasets created
#'   with \code{dataset_df()}. All variable-level attributes — including labels,
#' units, concept definitions, and namespaces — must match. If \code{strict =
#' TRUE} (the default), the row identifier namespace (used in the \code{rowid}
#'   column) must also match exactly.
#'
#'   If \code{strict = FALSE}, row identifiers from \code{y} may differ and will
#'   be ignored; the output will inherit \code{x}'s row identifier scheme.
#'
#' @param x A `dataset_df` object.
#' @param y A `dataset_df` object to bind to `x`.
#' @param ... Optional dataset-level attributes such as \code{title} or
#'   \code{creator} to override.
#' @param strict Logical. If \code{TRUE} (default), require full semantic
#'   compatibility, including rowid.
#'
#' @return A new `dataset_df` object with rows from `x` and `y`, combined
#'   semantically.
#'
#' @export
#' @examples
#' A <- dataset_df(
#'   length = defined(c(10, 15),
#'     label = "Length",
#'     unit = "cm", namespace = "http://example.org"
#'   ),
#'   identifier = c(id = "http://example.org/dataset#"),
#'   dataset_bibentry = dublincore(
#'     title = "Dataset A",
#'     creator = person("Alice", "Smith")
#'   )
#' )
#'
#' B <- dataset_df(
#'   length = defined(c(20, 25),
#'     label = "Length",
#'     unit = "cm", namespace = "http://example.org"
#'   ),
#'   identifier = c(id = "http://example.org/dataset#")
#' )
#'
#' bind_defined_rows(A, B) # succeeds
#'
#' C <- dataset_df(
#'   length = defined(c(30, 35),
#'     label = "Length",
#'     unit = "cm", namespace = "http://example.org"
#'   ),
#'   identifier = c(id = "http://another.org/dataset#")
#' )
#'
#' \dontrun{
#' bind_defined_rows(A, C, strict = TRUE) # fails: mismatched rowid
#' }
#'
#' bind_defined_rows(A, C, strict = FALSE) # succeeds: rowid inherited
bind_defined_rows <- function(x, y, ..., strict = FALSE) {
  dots <- list(...)

  if (!inherits(x, "dataset_df")) {
    stop(
      "`x` must be a dataset_df object. Got: ",
      paste(class(x), collapse = ", ")
    )
  }

  if (!inherits(y, "dataset_df")) {
    stop(
      "`y` must be a dataset_df object. Got: ",
      paste(class(y), collapse = ", ")
    )
  }


  # Strict mode: also validate rowid identifier
  if (strict) {
    ns_x <- namespace_attribute(x[["rowid"]])
    ns_y <- namespace_attribute(y[["rowid"]])

    if (!identical(ns_x, ns_y)) {
      stop("Row identifier namespaces must match in strict mode.")
    }
  }

  # Exclude rowid from semantic checks
  vars <- setdiff(names(x), "rowid")

  if (!identical(names(x)[vars], names(y)[vars])) {
    stop("Error: Column names must match between datasets.")
  }

  if (!identical(var_label(x[vars]), var_label(y[vars]))) {
    stop("Error: Variable labels must match in the two datasets.")
  }

  if (!identical(lapply(x[vars], var_unit), lapply(y[vars], var_unit))) {
    stop("Error: Variable units must match in the two datasets.")
  }

  if (!identical(
    lapply(x[vars], function(i) attr(i, "concept")),
    lapply(y[vars], function(j) attr(j, "concept"))
  )) {
    stop("Variable concept definitions must match in the two datasets.")
  }

  if (!identical(
    lapply(x[vars], namespace_attribute),
    lapply(y[vars], namespace_attribute)
  )
  ) {
    stop("Variable namespaces must match in the two datasets.")
  }

  # Bind only variable columns (exclude rowid)
  new_data <- mapply(function(a, b) c(a, b), x[vars], y[vars], SIMPLIFY = FALSE)

  # Use the rowid namespace from x; allow override later if needed
  new_dataset <- do.call(dataset_df, c(new_data, list(identifier = namespace_attribute(x[["rowid"]]))))

  # Handle title/creator if supplied
  if (!is.null(dots$title)) dataset_title(new_dataset, overwrite = TRUE) <- dots$title
  if (!is.null(dots$creator)) {
    creator(new_dataset) <- dots$creator
  } else {
    creator(new_dataset) <- compare_creators(x, y)
  }

  attr(new_dataset, "dataset_bibentry") <- attr(x, "dataset_bibentry")
  new_dataset
}
#' @keywords internal
compare_creators <- function(x, y) {
  creators_x <- creator(x)
  creators_y <- creator(y)
  all_creators <- c(creators_x, creators_y)

  identity_keys <- vapply(all_creators, function(p) {
    paste(
      p$given %||% "",
      p$family %||% "",
      p$email %||% "",
      p$comment %||% "",
      sep = "|"
    )
  }, character(1))

  unique_keys <- unique(identity_keys)
  merged <- vector("list", length(unique_keys))

  for (i in seq_along(unique_keys)) {
    key <- unique_keys[i]
    matches <- all_creators[identity_keys == key]
    roles <- unique(unlist(lapply(matches, function(p) p$role)))
    base <- matches[[1]]

    merged[[i]] <- person(
      given = base$given,
      family = base$family,
      email = base$email,
      comment = base$comment,
      role = roles
    )
  }

  do.call(c, merged)
}
#' @title Get or set contributors
#'
#' @description `contributor()` is a lightweight wrapper around [creator()] that
#'   works only with contributors. It retrieves or updates only the contributor
#'   entries in the dataset's bibliographic metadata.
#'
#' @details All people are stored in the `author` slot of the underlying
#'   [`utils::bibentry`]. This helper preserves primary creators and filters or
#'   updates only those entries that represent contributors.
#'
#'   A *contributor* is defined as:
#'
#' * a person with `role == "ctb"`, **or**
#' * a person with a `comment[["contributorType"]]`.
#'
#'   Primary creators (authors) typically have `role %in% c("aut", "cre")`.
#'
#'   Contributors can be further annotated with metadata in `comment`, for
#'   example:
#'
#' ```r
#' comment = c(contributorType = "hostingInstitution", ORCID = "0000-0000-0000-0000")
#' ```
#'
#' @param x A dataset object created with [dataset_df()] or [as_dataset_df()].
#' @param value A [`utils::person`] object representing a single contributor. If
#'   the `role` field is missing, it will be set to `"ctb"`. If `NULL`, the
#'   dataset is returned unchanged.
#' @param overwrite Logical. If `TRUE`, replace all existing contributors with
#'   `value`. If `FALSE`, append `value` to the existing contributors. Defaults
#'   to `FALSE`.
#'
#' @return
#' * `contributor()` returns a [`utils::person`] or a list of such objects
#' corresponding to contributors.
#' * `contributor<-()` returns the updated dataset (invisibly).
#'
#' @examples
#' df <- dataset_df(data.frame(x = 1))
#' creator(df) <- person("Jane", "Doe", role = "aut")
#'
#' # Add a contributor
#' contributor(df, overwrite = FALSE) <-
#'   person("GitHub",
#'     role = "ctb",
#'     comment = c(contributorType = "hostingInstitution")
#'   )
#'
#' # Replace all contributors
#' contributor(df) <- person("Support", "Team", role = "ctb")
#'
#' # Inspect only contributors
#' contributor(df)
#'
#' @family bibliographic helper functions
#' @importFrom utils person
#' @export
contributor <- function(x) {
  assertthat::assert_that(
    is.dataset_df(x),
    msg = "contributor(x): x must be a dataset created with dataset_df() or as_dataset_df()."
  )
  auth <- get_bibentry(x)$author
  if (is.null(auth)) {
    return(auth)
  }

  as_list <- as.list(auth)
  is_ctb <- function(p) {
    inherits(p, "person") &&
      (identical(p$role, "ctb") ||
        (!is.null(p$comment) && !is.null(p$comment[["contributorType"]])))
  }
  keep <- vapply(as_list, is_ctb, logical(1))
  if (!any(keep)) {
    return(auth[0])
  }
  utils::as.person(as_list[keep])
}


#' @rdname contributor
#' @export
`contributor<-` <- function(x, overwrite = FALSE, value) {
  assertthat::assert_that(
    is.dataset_df(x),
    msg = "contributor(x) <- value: x must be a dataset_df object."
  )
  if (is.null(value)) {
    return(x)
  }
  if (!inherits(value, "person")) {
    stop("contributor(x) <- value: `value` must be a utils::person object.")
  }
  if (is.null(value$role)) value$role <- "ctb"
  if (!identical(value$role, "ctb")) {
    stop("contributor(x) <- value: role must be 'ctb'.")
  }

  all_people <- get_bibentry(x)$author
  non_ctb <- Filter(function(p) !identical(p$role, "ctb"), as.list(all_people))

  new_auth <- if (overwrite) {
    c(non_ctb, value)
  } else {
    c(all_people, value)
  }

  databibentry <- attr(x, "dataset_bibentry")
  databibentry$author <- utils::as.person(new_auth)
  attr(x, "dataset_bibentry") <- databibentry
  invisible(x)
}
#' @title Get/set the Creator of the object.
#' @description Add the optional `Creator` property as an attribute to a
#'   dataset object.
#' @details The `Creator` corresponds to
#'   [dct:creator](https://www.dublincore.org/specifications/dublin-core/dcmi-terms/elements11/creator/)
#'   in Dublin Core and Creator in DataCite. The name of the entity that holds,
#'   archives, publishes prints, distributes, releases, issues, or produces the
#'   dataset. This property will be used to formulate the citation, so consider
#'   the prominence of the role.
#' @param x A semantically rich data frame object created by
#'   [dataset_df()] or `dataset::\link{as_dataset_df}`.
#' @param value The `Creator` as a
#'   [utils::person()] object.
#' @param overwrite If the attributes should be overwritten. In case it is set
#'   to `FALSE`,it gives a message with the current `Creator` property
#'   instead of overwriting it. Defaults to `TRUE` when the attribute is
#'   set to `value` regardless of previous setting.
#' @return The Creator attribute as a character of length one is added to
#'   `x`.
#' @importFrom utils person
#' @importFrom assertthat assert_that
#' @family bibliographic helper functions
#' @examples
#' creator(orange_df)
#' # To change author:
#' creator(orange_df) <- person("Jane", "Doe")
#' # To add author:
#' creator(orange_df, overwrite = FALSE) <- person("John", "Doe")
#' @export
creator <- function(x) {
  assert_that(is.dataset_df(x),
    msg = "creator(x): x must be a dataset object created with dataset() or as_dataset_df()."
  )

  ds_bibentry <- get_bibentry(x)
  ds_bibentry$author
}

#' @rdname creator
#' @export
`creator<-` <- function(x, overwrite = TRUE, value) {
  assert_that(is.dataset_df(x),
    msg = "creator(x) <- value: x must be a dataset object created with dataset_df() or as_dataset_df()."
  )

  if (is.null(value)) {
    return(x)
  }

  if (!inherits(value, "person")) {
    stop("creator(x) <- value: `value` must be a utils::person object.")
  }

  ds_creator <- get_bibentry(x)$author

  if (overwrite) {
    ds_creator <- value
  } else {
    ds_creator <- c(ds_creator, value)
  }

  databibentry <- attr(x, "dataset_bibentry")
  databibentry$author <- ds_creator
  attr(x, "dataset_bibentry") <- databibentry
  invisible(x)
}
#' A Small GDP Dataset
#'
#' A compact sample of GDP and main aggregates from Eurostat's annual
#' international cooperation dataset. This data subset contains illustrative
#' records for select countries and time periods.
#'
#' @format A data frame with 10 rows and 5 variables:
#' - `geo`: Country name (character)
#' - `year`: Reference year (integer)
#' - `gdp`: Gross Domestic Product value (numeric)
#' - `unit`: Unit of measurement, e.g., "Million EUR" (character)
#' - `freq`: Observation frequency, e.g., "Annual" (character)
#'
#' @details
#' This dataset is intended for examples, tests, and demonstration purposes. It
#' reflects simplified GDP data as published by Eurostat. The actual Eurostat
#' dataset includes more countries, breakdowns, and metadata.
#'
#' @source Eurostat (2021). GDP and main aggregates - international data
#' cooperation (annual data). \doi{10.2908/NAIDA_10_GDP}
#'
#' @keywords datasets
#' @examples
#' head(gdp)
"gdp"
#' Create a Bibentry Object with DataCite Metadata Fields
#'
#' Constructs a bibliographic metadata record conforming to the
#' [DataCite Metadata Schema](https://schema.datacite.org/). The resulting
#' object is stored as a modified [utils::bibentry()] enriched with structured
#' Dublin Core and DataCite-compliant metadata.
#'
#' @details
#' DataCite is a leading non-profit organization that provides persistent
#' identifiers (DOIs) for research data and other research outputs. Members of
#' the research community use DataCite to register datasets with globally
#' resolvable metadata for citation and discovery.
#'
#' This function sets `"Dataset"` as the default resource type. The `Size`
#' attribute (e.g., bytes, pages, etc.) is automatically added if available.
#'
#' @param Title The name(s) by which the resource is known. Similar to
#'   [dct:title](https://www.dublincore.org/specifications/dublin-core/dcmi-terms/elements11/title/).
#' @param Creator One or more [utils::person()] objects describing the main
#'   authors or contributors responsible for creating the resource.
#' @param Identifier A persistent identifier (e.g., DOI or URI). May refer to a
#'   specific version or all versions of the resource.
#' @param Publisher The name of the organization that holds, publishes, or
#'   distributes the resource. Required by DataCite. See [publisher()].
#' @param PublicationYear The year of public availability (in `YYYY` format).
#'   See [publication_year()].
#' @param Subject A topic, keyword, or classification term. See [subject()] and
#'   [subject_create()] for structured vocabularies.
#' @param Contributor An individual or institution that contributed to the
#'   development, distribution, or curation of the resource.
#' @param Type The resource type. Defaults to `"Dataset"` for general use. See
#'   [dcm:type](https://www.dublincore.org/specifications/dublin-core/dcmi-terms/elements11/type/).
#' @param Language Language code as per IETF BCP 47 / ISO 639-1. See [language()].
#' @param AlternateIdentifier Optional local or secondary identifier. Defaults
#'   to `":unas"`.
#' @param RelatedIdentifier Related resources (e.g., prior versions, papers).
#'   Defaults to `":unas"`.
#' @param Format A technical format (e.g., `"application/pdf"`, `"text/csv"`).
#' @param Version A free-text version string (e.g., `"1.0.0"`). Defaults to
#'   `"0.1.0"`. See [version()].
#' @param Rights Licensing or usage restrictions for the resource. Defaults to
#'   `":tba"`. See [rights()].
#' @param Date A date in `"YYYY"`, `"YYYY-MM-DD"` or ISO datetime format.
#'   Can also be a [Date] or [POSIXct] object.
#' @param DateList A list of multiple dates. Currently not supported.
#' @param Description Free-text summary or additional information. Defaults to
#'   `":tba"`.
#' @param Geolocation Geographic location covered or referenced by the resource.
#'   See [geolocation()].
#' @param FundingReference Information about funding or financial support.
#'   Defaults to `":unas"`. Structured funding metadata not yet implemented.
#'
#' @return
#' A [utils::bibentry()] object with DataCite-compliant fields. Use
#' [as_datacite()] to extract the metadata as a list or bibentry object.
#'
#' @source
#' - [DataCite 4.3 Mandatory Properties](https://support.datacite.org/docs/schema-mandatory-properties-v43)
#' - [DataCite 4.3 Optional Properties](https://support.datacite.org/docs/schema-optional-properties-v43)
#'
#' @family bibrecord functions
#' @seealso
#' Learn more in the vignette:
#' [`bibrecord`](https://dataset.dataobservatory.eu/articles/bibrecord.html)
#' @importFrom utils person bibentry
#'
#' @examples
#' datacite(
#'   Title = "Growth of Orange Trees",
#'   Creator = c(
#'     person(
#'       given = "N.R.",
#'       family = "Draper",
#'       role = "cre",
#'       comment = c(VIAF = "http://viaf.org/viaf/84585260")
#'     ),
#'     person(
#'       given = "H",
#'       family = "Smith",
#'       role = "cre"
#'     )
#'   ),
#'   Publisher = "Wiley",
#'   Date = 1998,
#'   Language = "en"
#' )
#'
#' # Extract bibliographic metadata
#' as_datacite(orange_df)
#'
#' # As a list
#' as_datacite(orange_df, "list")
#'
#' @export

datacite <- function(Title,
                     Creator,
                     Identifier = NULL,
                     Publisher = NULL,
                     PublicationYear = NULL,
                     Subject = subject_create(
                       term = "data sets",
                       subjectScheme = "Library of Congress Subject Headings (LCSH)",
                       schemeURI = "https://id.loc.gov/authorities/subjects.html",
                       valueURI = "http://id.loc.gov/authorities/subjects/sh2018002256"
                     ),
                     Type = "Dataset",
                     Contributor = NULL,
                     Date = ":tba",
                     DateList = NULL,
                     Language = NULL,
                     AlternateIdentifier = ":unas",
                     RelatedIdentifier = ":unas",
                     Format = ":tba",
                     Version = "0.1.0",
                     Rights = ":tba",
                     Description = ":tba",
                     Geolocation = ":unas",
                     FundingReference = ":unas") {
  if (is.null(PublicationYear)) {
    if (!is.null(Date) && grepl("^\\d{4}", as.character(Date))) {
      PublicationYear <- substr(as.character(Date), 1, 4)
    } else {
      PublicationYear <- ":tba"
    }
  }

  Date <- ifelse(is.null(DateList), ":tba", as.character(Date))
  DateList <- ifelse(is.null(DateList), ":tba", as.character(DateList))
  Format <- ifelse(is.null(Format), ":tba", as.character(Format))
  AlternateIdentifier <- ifelse(is.null(AlternateIdentifier),
    ":unas", AlternateIdentifier
  )
  if (is.null(RelatedIdentifier)) {
    RelatedIdentifie <- ":unas"
  }
  Rights <- ifelse(is.null(Rights), ":tba", as.character(Rights))
  Geolocation <- ifelse(is.null(Geolocation), ":unas",
    as.character(Geolocation)
  )
  FundingReference <- ifelse(is.null(FundingReference),
    ":unas", as.character(FundingReference)
  )

  new_datacite(
    Title = Title,
    Creator = Creator,
    Identifier = Identifier,
    Publisher = Publisher,
    PublicationYear = PublicationYear,
    Subject = Subject,
    Type = "Dataset",
    Contributor = Contributor,
    Date = Date,
    DateList = DateList,
    Language = Language,
    AlternateIdentifier = AlternateIdentifier,
    RelatedIdentifier = RelatedIdentifier,
    Format = Format,
    Version = Version,
    Rights = Rights,
    Description = Description,
    Geolocation = Geolocation,
    FundingReference = FundingReference
  )
}

#' @keywords internal
new_datacite <- function(Title,
                         Creator,
                         Identifier,
                         Publisher,
                         PublicationYear,
                         Subject,
                         Type = "Dataset",
                         Contributor,
                         Date,
                         DateList,
                         Language,
                         AlternateIdentifier,
                         RelatedIdentifier,
                         Format,
                         Version,
                         Rights,
                         Description,
                         Geolocation,
                         FundingReference) {
  # bibentry: subject slot must be character
  datacite_object <- bibentry(
    bibtype = "Misc",
    title = Title,
    author = Creator,
    year = as.character(PublicationYear),
    identifier = Identifier,
    publisher = Publisher,
    date = Date,
    language = Language,
    subject = if (is.subject(Subject)) Subject$term else as.character(Subject),
    alternateidentifier = AlternateIdentifier,
    relatedidentifier = if (is.related(RelatedIdentifier)) {
      RelatedIdentifier$relatedIdentifier
    } else if (is.null(RelatedIdentifier)) {
      ":unas"
    } else {
      as.character(RelatedIdentifier)
    },
    format = Format,
    version = Version,
    rights = Rights,
    description = Description,
    geolocation = Geolocation,
    fundingreference = FundingReference
  )

  # keep the structured subject object as an attribute
  if (!is.null(Subject) && is.subject(Subject)) {
    attr(datacite_object, "subject") <- Subject
  }

  # keep the structured related item object as an attribute
  if (!is.null(RelatedIdentifier) && is.related(RelatedIdentifier)) {
    attr(datacite_object, "relatedIdentifier") <- RelatedIdentifier
  }

  # add structured contributor list
  if (!is.null(Contributor)) {
    attr(datacite_object, "contributor") <- Contributor
  }

  class(datacite_object) <- c("datacite", class(datacite_object))
  datacite_object
}

#' @rdname datacite
#' @return \code{is.datacite(x)} returns a logical values (if the object
#' \code{x} is of class \code{datacite}).
is.datacite <- function(x) {
  UseMethod("is.datacite", x)
}

#' @rdname datacite
#' @param x An object that is tested if it has a class "datacite".
#' @exportS3Method
is.datacite.datacite <- function(x) inherits(x, "datacite")

#' @rdname datacite
#' @exportS3Method
print.datacite <- function(x, ...) {
  cat("DataCite Metadata Record\n")
  cat("--------------------------\n")

  pr <- function(label, value) {
    if (!is.null(value) && length(value) > 0 && any(nzchar(value))) {
      # %-12s = left-justify label into 12 chars
      cat(sprintf("%-12s %s\n", paste0(label, ":"), paste(value, collapse = "; ")))
    }
  }

  pr("Title", x$title)
  pr("Creator(s)", paste(format(x$author), collapse = "; "))

  contributor <- attr(x, "contributor")
  if (!is.null(contributor)) {
    pr("Contributor(s)", fix_contributor(contributor))
  }

  subj <- attr(x, "subject")
  if (!is.null(subj) && is.subject(subj)) {
    subj_val <- subj$term
    if (!is.null(subj$schemeURI) && nzchar(subj$schemeURI)) {
      subj_val <- paste0(subj_val, " [", subj$schemeURI, "]")
    }
    pr("Subject(s)", subj_val)
  } else if (!is.null(x$subject)) {
    pr("Subject(s)", x$subject)
  }

  pr("Identifier", x$identifier)
  pr("Publisher", x$publisher)
  pr("Year", x$year)
  pr("Language", x$language)
  pr("Description", x$description)

  invisible(x)
}
#' @keywords internal
datacite_to_triples <- function(dc_list,
                                dataset_id = "http://example.com/dataset") {
  if (is.null(dc_list$title) || nchar(dc_list$title) == 0) {
    stop("datacite_to_triples(): title is required")
  }

  base <- "http://datacite.org/schema/kernel-4/"
  triples <- character()

  triples <- c(triples, n_triple(
    dataset_id,
    paste0(base, "title"), dc_list$title
  ))

  if (!is.null(dc_list$author)) {
    triples <- c(triples, n_triple(
      dataset_id,
      paste0(base, "creator"),
      dc_list$author
    ))
  }

  if (!is.null(dc_list$contributor)) {
    triples <- c(triples, n_triple(
      dataset_id,
      paste0(base, "contributor"),
      dc_list$contributor
    ))
  }

  if (!is.null(dc_list$identifier)) {
    triples <- c(triples, n_triple(
      dataset_id,
      paste0(base, "identifier"),
      dc_list$identifier
    ))
  }

  if (!is.null(dc_list$publisher)) {
    triples <- c(triples, n_triple(
      dataset_id,
      paste0(base, "publisher"),
      dc_list$publisher
    ))
  }

  if (!is.null(dc_list$publicationyear)) {
    triples <- c(triples, n_triple(
      dataset_id,
      paste0(base, "publicationYear"),
      dc_list$publicationyear
    ))
  }

  if (!is.null(dc_list$language)) {
    triples <- c(triples, n_triple(
      dataset_id,
      paste0(base, "language"),
      dc_list$language
    ))
  }

  if (!is.null(dc_list$rights)) {
    triples <- c(triples, n_triple(dataset_id, paste0(base, "rights"), dc_list$rights))
  }

  if (!is.null(dc_list$description)) {
    triples <- c(triples, n_triple(
      dataset_id,
      paste0(base, "descriptions"),
      dc_list$description
    ))
  }

  if (!is.null(dc_list$subject)) {
    subj_value <- dc_list$subject

    if (is.subject(subj_value)) {
      subj_value <- subj_value$term
    } else if (is.list(subj_value)) {
      subj_value <- vapply(subj_value, function(s) {
        if (is.subject(s)) {
          s$term
        } else {
          as.character(s)
        }
      }, character(1))
    } else {
      subj_value <- as.character(subj_value)
    }

    triples <- c(triples, n_triple(
      dataset_id,
      paste0(base, "subjects"),
      subj_value
    ))
  }


  if (!is.null(dc_list$format)) {
    triples <- c(triples, n_triple(
      dataset_id,
      paste0(base, "formats"),
      dc_list$format
    ))
  }

  if (!is.null(dc_list$version)) {
    triples <- c(triples, n_triple(
      dataset_id,
      paste0(base, "version"),
      dc_list$version
    ))
  }

  # --- Related identifiers ---
  rel_attr <- attr(dc_list, "relation", exact = TRUE)
  if (!is.null(rel_attr)) {
    # normalize: single object → list
    if (is.related(rel_attr)) rel_attr <- list(rel_attr)

    if (is.list(rel_attr) && all(vapply(rel_attr, is.related, logical(1)))) {
      for (ri in rel_attr) {
        triples <- c(
          triples,
          n_triple(
            dataset_id,
            paste0(base, "relatedIdentifier"),
            ri$relatedIdentifier
          ),
          n_triple(
            dataset_id,
            paste0(base, "relationType"),
            ri$relationType
          ),
          n_triple(
            dataset_id,
            paste0(base, "relatedIdentifierType"),
            ri$relatedIdentifierType
          )
        )
        if (!is.null(ri$resourceTypeGeneral) && nzchar(ri$resourceTypeGeneral)) {
          triples <- c(
            triples,
            n_triple(
              dataset_id,
              paste0(base, "resourceTypeGeneral"),
              ri$resourceTypeGeneral
            )
          )
        }
      }
    }
  } else if (!is.null(dc_list$relatedidentifier) &&
    dc_list$relatedidentifier != ":unas") {
    triples <- c(
      triples,
      n_triple(
        dataset_id,
        paste0(base, "relatedIdentifier"),
        dc_list$relatedidentifier
      )
    )
  }


  n_triples(triples)
}
#' Growth of Orange Trees
#'
#' A dataset recording the growth of orange trees, replicated from the classic
#' [`datasets::Orange`](https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/Orange.html)
#' dataset and implemented as a `dataset_df` S3 class with enhanced semantic metadata.
#'
#' @format A data frame with 35 rows and 4 variables:
#' - `rowid`: A unique identifier for each row (character)
#' - `tree`: Tree identifier (ordered factor)
#' - `age`: Age of the tree in days (numeric)
#' - `circumference`: Trunk circumference in mm (numeric)
#'
#' @details
#' This is a semantically enriched version of the classic Orange dataset,
#' constructed using the `dataset_df()` and `dublincore()` constructors.
#' Each column includes semantic metadata such as units, labels, concepts,
#' or namespace identifiers. The dataset also embeds a machine-readable citation
#' for reproducibility and provenance tracking.
#'
#' ### Constructor Example
#' ```r
#' orange_bibentry <- dublincore(
#'   title = "Growth of Orange Trees",
#'   creator = c(
#'     person(
#'       given = "N.R.",
#'       family = "Draper",
#'       role = "cre",
#'       comment = c(VIAF = "http://viaf.org/viaf/84585260")
#'     ),
#'     person(
#'       given = "H",
#'       family = "Smith",
#'       role = "cre"
#'     )
#'   ),
#'   contributor = person(
#'     given = "Antal",
#'     family = "Daniel",
#'     role = "dtm"
#'   ),
#'   publisher = "Wiley",
#'   datasource = "https://isbnsearch.org/isbn/9780471170822",
#'   dataset_date = 1998,
#'   identifier = "https://doi.org/10.5281/zenodo.14917851",
#'   language = "en",
#'   description = "The Orange data frame has 35 rows and 3 columns of records of the growth of orange trees."
#' )
#'
#' orange_df <- dataset_df(
#'   rowid = defined(paste0("orange:", row.names(Orange)),
#'     label = "ID in the Orange dataset",
#'     namespace = c("orange" = "datasets::Orange")
#'   ),
#'   tree = defined(Orange$Tree,
#'     label = "The number of the tree"
#'   ),
#'   age = defined(Orange$age,
#'     label = "The age of the tree",
#'     unit = "days since 1968/12/31"
#'   ),
#'   circumference = defined(Orange$circumference,
#'     label = "circumference at breast height",
#'     unit = "milimeter",
#'     concept = "https://www.wikidata.org/wiki/Property:P2043"
#'   ),
#'   dataset_bibentry = orange_bibentry
#' )
#'
#' orange_df$rowid <- defined(orange_df$rowid,
#'   namespace = "https://doi.org/10.5281/zenodo.14917851"
#' )
#' ```
#' @references
#' - Draper, N. R. & Smith, H. (1998). *Applied Regression Analysis* (3rd ed.). Wiley.
#' - Pinheiro, J. C. & Bates, D. M. (2000). *Mixed-effects Models in S and S-PLUS*. Springer.
#' - Becker, R. A., Chambers, J. M. & Wilks, A. R. (1988). *The New S Language*. Wadsworth & Brooks/Cole.
#'
#' @examples
#' # Print with semantic citation and data preview
#' print(orange_df)
#'
#' # Access semantic metadata associated with variables
#' print(orange_df$age)
#'
#' # Retrieve the embedded bibliographic record
#' as_dublincore(orange_df)
#'
#' @keywords datasets
"orange_df"
#' Create a new `dataset_df` object
#'
#' The `dataset_df()` constructor creates semantically rich modern data frames.
#' These inherit from [`tibble::tibble`] and carry structured metadata using
#' attributes.
#'
#' Use `is.dataset_df()` to check class membership.
#'
#' S3 methods for `dataset_df` include:
#' - `print()` to display the dataset with metadata
#' - `summary()` to summarize both data and metadata
#'
#' For full details, see `vignette("dataset_df", package = "dataset")`.
#'
#' @param ... Vectors (columns) that should be included in the dataset.
#' @param identifier A named vector of one or more URI prefixes for row IDs.
#'   Defaults to `c(eg = "http://example.com/dataset#")`. For example, if your
#'   dataset will be published under DOI `https://doi.org/1234`, you may use
#'   `c(obs = "https://doi.org/1234#")`, which will generate row URIs such as
#'   `https://doi.org/1234#1`, ..., `#n`.
#' @param dataset_bibentry A bibliographic metadata record for the dataset,
#'   created using [`datacite()`] or [`dublincore()`].
#' @param var_labels A named list of human-readable labels for each variable.
#' @param units A named list of measurement units for measured variables.
#' @param concepts A named list of linked concepts (URIs) for variables or
#'   dimensions.
#' @param dataset_subject A subject descriptor created with [`subject()`] or
#'   [`subject_create()`].
#' @param x A `dataset_df` object (used in method dispatch).
#' @param df A `data.frame` to convert to a `dataset_df`.
#'
#' @return A `dataset_df` object: a tibble with attached metadata stored in
#'   attributes.
#'
#' @note A simple, serverless scaffolding for publishing `dataset_df` objects
#'   on the web (with HTML + RDF exports) is available at
#'   <https://github.com/dataobservatory-eu/dataset-template>.
#'
#' @examples
#' my_dataset <- dataset_df(
#'   country_name = defined(
#'     c("AD", "LI"),
#'     concept = "http://data.europa.eu/bna/c_6c2bb82d",
#'     namespace = "https://www.geonames.org/countries/$1/"
#'   ),
#'   gdp = defined(
#'     c(3897, 7365),
#'     label = "Gross Domestic Product",
#'     unit = "million dollars",
#'     concept = "http://data.europa.eu/83i/aa/GDP"
#'   ),
#'   identifier = c(
#'     obs = "https://dataobservatory-eu.github.io/dataset-template#"
#'   ),
#'   dataset_bibentry = dublincore(
#'     title = "GDP of Andorra and Liechtenstein",
#'     description = "A small but semantically rich dataset example.",
#'     creator = person("Jane", "Doe", role = "cre"),
#'     publisher = "Open Data Institute",
#'     language = "en"
#'   )
#' )
#'
#' # Basic usage
#' print(my_dataset)
#' head(my_dataset)
#' summary(my_dataset)
#'
#' # Metadata access
#' as_dublincore(my_dataset)
#' as_datacite(my_dataset)
#'
#' # Export description as RDF triples
#' my_description <- describe(my_dataset, con = tempfile())
#' my_description
#'
#' @seealso [defined()], [dublincore()], [datacite()], [subject()]
#'
#' @export

# User constructor
dataset_df <- function(
    ...,
    identifier = c(obs = "http://example.com/dataset#obs"),
    var_labels = NULL,
    units = NULL,
    concepts = NULL,
    dataset_bibentry = NULL,
    dataset_subject = NULL) {
  dots <- list(...)

  if (!"rowid" %in% names(dots)) {
    add_rowid <- TRUE
  } else {
    add_row_id <- FALSE
  }

  sys_time <- Sys.time()
  year <- substr(as.character(sys_time), 1, 4)

  if (is.null(dataset_subject)) {
    dataset_subject <- default_subject # See: subject.R
  }

  if (is.null(dataset_bibentry)) {
    Title <- "Untitled Dataset"
    Creator <- person("Author", "Unknown")
    dataset_bibentry <- datacite(
      Title = Title,
      Creator = Creator,
      Subject = dataset_subject,
      Date = Sys.Date()
    )
  }

  tmp <- new_dataset(
    x = tibble::tibble(...),
    identifier = identifier,
    dataset_bibentry = dataset_bibentry,
    var_labels = var_labels,
    units = units,
    concepts = concepts
  )

  dataset_bibentry <- get_bibentry(tmp)
  if (dataset_bibentry$year == ":tba") dataset_bibentry$year <- year
  if (dataset_bibentry$date == ":tba") {
    dataset_bibentry$date <- as.character(Sys.Date())
  }

  attr(tmp, "dataset_bibentry") <- dataset_bibentry
  attr(tmp, "subject") <- dataset_subject
  tmp
}

#' @rdname dataset_df
#' @export
as_dataset_df <- function(
    df,
    identifier = c(obs = "http://example.com/dataset#obs"),
    var_labels = NULL,
    units = NULL,
    concepts = NULL,
    dataset_bibentry = NULL,
    dataset_subject = NULL, ...) {
  dots <- list(...)

  if (is.null(dots$dataset_bibentry)) {
    dataset_bibentry <- set_default_bibentry()
  }

  new_dataset(df,
    identifier = identifier,
    dataset_bibentry = dataset_bibentry,
    var_labels = var_labels,
    units = units,
    concepts = concepts
  )
}

# Developer constructor
#' @importFrom tibble new_tibble
#' @keywords internal
new_dataset <- function(x,
                        add_rowid = TRUE,
                        identifier,
                        dataset_bibentry = NULL,
                        var_labels = NULL,
                        units = NULL,
                        concepts = NULL) {
  assertthat::assert_that(is.data.frame(x),
    msg = "Error: new_dataset(x): x is not a data frame"
  )

  generated_at_time <- Sys.time()

  tmp <- tibble::new_tibble(
    x,
    class = "dataset_df",
    nrow = nrow(x)
  )

  add_rowid <- ifelse("rowid" %in% names(tmp), FALSE, TRUE)

  if (add_rowid) {
    tmp <- tibble::rowid_to_column(tmp)
    prefix <- names(identifier)[1]
    tmp$rowid <- defined(paste0(prefix, tmp$rowid),
      namespace = identifier
    )
  }

  if (is.null(dataset_bibentry)) {
    dataset_bibentry <- set_default_bibentry()
  }

  attr(tmp, "dataset_bibentry") <- dataset_bibentry

  # tmp <- set_var_labels(tmp, var_labels = var_labels)

  prov <- default_provenance(
    generated_at_time = generated_at_time,
    author = dataset_bibentry$author
  )

  attr(tmp, "prov") <- prov

  tmp
}

#' @rdname dataset_df
#' @return `is.dataset_df` returns a logical value
#' (if the object is of class `dataset_df`.)
#' @export
is.dataset_df <- function(x) {
  ifelse("dataset_df" %in% class(x), TRUE, FALSE)
}

#' @rdname dataset_df
#' @export
print.dataset_df <- function(x, ...) {
  dataset_bibentry <- get_bibentry(x)
  if (is.null(dataset_bibentry)) {
    dataset_bibentry <- set_default_bibentry()
  }

  # Extract fields
  authors <- dataset_bibentry$author
  year <- dataset_bibentry$year
  title <- dataset_bibentry$title
  doi <- dataset_bibentry$identifier
  dataset_date <- dataset_bibentry$Date

  # Format author(s)
  author_fmt <- function(authors) {
    if (length(authors) == 1) {
      return(authors[[1]]$family %||% format(authors[[1]]))
    }

    is_institutional <- vapply(
      authors,
      function(a) is.null(a$given) && !is.null(a$family),
      logical(1)
    )
    if (all(is_institutional)) {
      return(paste(
        vapply(
          authors,
          function(a) a$family, character(1)
        ),
        collapse = "-"
      ))
    }

    if (length(authors) == 2) {
      return(paste(vapply(
        authors,
        function(a) a$family,
        character(1)
      ), collapse = "-"))
    }

    return(paste0(authors[[1]]$family, " et al."))
  }

  apa_header <- sprintf(
    "%s (%s): %s [dataset]",
    author_fmt(authors),
    year,
    title
  )

  if (!is.null(doi) && grepl("doi.org", doi)) {
    apa_header <- paste0(apa_header, ", ", doi)
  }

  cat(trimws(apa_header), "\n", sep = "")

  # Generate the tibble-like format
  df_fmt <- format(x)
  table_header <- df_fmt[1]
  table_body <- df_fmt[-1]

  # Extract column header line
  col_line <- table_body[1]

  # Print column header, label row, and table body
  cat(col_line, "\n")
  cat(paste0(table_body[-1], collapse = "\n"), "\n")

  invisible(x)
}


#' @export
tbl_sum.dataset_df <- function(x, ...) {
  NextMethod()
}

#' @export
summary.dataset_df <- function(object, ...) {
  dataset_bibentry <- get_bibentry(object)
  if (is.null(dataset_bibentry)) {
    dataset_bibentry <- set_default_bibentry()
  }
  # Extract fields
  authors <- dataset_bibentry$author
  year <- dataset_bibentry$year
  title <- dataset_bibentry$title
  doi <- dataset_bibentry$identifier

  # Format author(s)
  author_fmt <- function(authors) {
    if (length(authors) == 1) {
      return(authors[[1]]$family %||% format(authors[[1]]))
    }

    is_institutional <- vapply(
      authors,
      function(a) is.null(a$given) && !is.null(a$family),
      logical(1)
    )
    if (all(is_institutional)) {
      return(paste(
        vapply(
          authors,
          function(a) a$family, character(1)
        ),
        collapse = "-"
      ))
    }

    if (length(authors) == 2) {
      return(paste(vapply(
        authors,
        function(a) a$family,
        character(1)
      ), collapse = "-"))
    }

    return(paste0(authors[[1]]$family, " et al."))
  }

  apa_header <- sprintf(
    "%s (%s): Summary of %s [dataset]",
    author_fmt(authors),
    year,
    title
  )


  if (!is.null(doi) && grepl("doi.org", doi)) {
    apa_header <- paste0(apa_header, ", ", doi)
  }

  cat(trimws(apa_header), "\n\n", sep = "")

  NextMethod()
}

#' @export
plot.dataset_df <- function(x, y = NULL, ..., main = NULL, sub = NULL) {
  title <- dataset_title(x)
  bib <- get_bibentry(x)
  author <- tryCatch(as.character(bib$author), error = function(e) "")
  year <- bib$year %||% substr(bib$date, 1, 4)
  publisher <- bib$publisher %||% ""

  main <- main %||% title
  sub <- sub %||% paste(author, "(", year, ")", "-", publisher)

  df <- as.data.frame(x)

  # Identify numeric or defined columns
  numeric_like_cols <- which(vapply(df, function(col) {
    inherits(col, "numeric") || inherits(col, "double") || inherits(col, "integer")
  }, logical(1)))

  if (length(numeric_like_cols) < 2) {
    stop("Not enough numeric or defined columns to create a plot.")
  }

  for (j in numeric_like_cols) {
    df[[j]] <- as_numeric(df[[j]])
  }

  xcol <- df[[numeric_like_cols[1]]]
  ycol <- df[[numeric_like_cols[2]]]

  x_label <- ifelse(is.null(var_label(x)[numeric_like_cols[1]][[1]]),
    names(x)[numeric_like_cols[1]],
    var_label(x)[numeric_like_cols[1]]
  )

  y_label <- ifelse(is.null(var_label(x)[numeric_like_cols[2]][[1]]),
    names(x)[numeric_like_cols[2]],
    var_label(x)[numeric_like_cols[2]]
  )

  plot(xcol, ycol,
    xlab = x_label,
    ylab = y_label,
    main = main,
    ...
  )
}



#' @rdname dataset_df
#' @export
is_dataset_df <- function(x) {
  inherits(x, "dataset_df")
}

#' @keywords internal
names.dataset_df <- function(x) {
  NextMethod("names")
}

#' @export
`[.dataset_df` <- function(x, i, j, drop = FALSE) {
  out <- NextMethod("[")
  attributes_to_preserve <- c("dataset_bibentry", "subject", "prov")

  for (attr_name in attributes_to_preserve) {
    attr(out, attr_name) <- attr(x, attr_name)
  }

  class(out) <- class(x)
  out
}
#' Get or set the technical format of a dataset
#'
#' Adds or retrieves the optional `"format"` field of a dataset's bibentry.
#' This field is the dataset's technical/media type (e.g., a MIME type).
#'
#' @details
#' The format field corresponds to
#' [dct:format](https://www.dublincore.org/specifications/dublin-core/dcmi-terms/elements11/format/)
#' in Dublin Core and to `format` in
#' [DataCite](https://schema.datacite.org/).
#' It is useful for indicating serialization such as `"text/csv"`,
#' `"application/parquet"`, or `"application/r-rds"`.
#'
#' If no format is set, this helper uses the package default
#' `"application/r-rds"`.
#'
#' @param x A semantically rich data frame created with [dataset_df()] or
#'   [as_dataset_df()].
#' @param value A length‑one character string specifying the format
#'   (e.g., `"text/csv"`). Use `NULL` to reset to the default.
#' @param overwrite Logical. Replace an existing non‑default value? If `FALSE`
#'   and a non‑default value already exists, a message is emitted and the value
#'   is kept. Defaults to `FALSE`.
#'
#' @return
#' The `"format"` (technical format) as a character string (length 1).
#' When assigning, the updated object `x` is returned invisibly.
#'
#' @examples
#' dataset_format(orange_df) <- "text/csv"
#' dataset_format(orange_df)
#'
#' # Reset to the package default
#' dataset_format(orange_df) <- NULL
#'
#' @family bibliographic helper functions
#' @importFrom assertthat assert_that
#' @export
dataset_format <- function(x) {
  assertthat::assert_that(
    is.dataset_df(x),
    msg = "dataset_format(x): x must be a dataset object created with dataset_df() or as_dataset_df()."
  )
  be <- get_bibentry(x)
  val <- be$format
  if (is.null(val)) "application/r-rds" else as.character(val)
}

#' @rdname dataset_format
#' @export
`dataset_format<-` <- function(x, overwrite = FALSE, value) {
  assertthat::assert_that(
    is.dataset_df(x),
    msg = "dataset_format(x) <- value: x must be a dataset object created with dataset_df() or as_dataset_df()."
  )
  assertthat::assert_that(
    is.null(value) || length(value) == 1,
    msg = "dataset_format(x) <- value: `value` must be length 1 or NULL."
  )

  be <- get_bibentry(x)

  if (is.null(value)) {
    be$format <- "application/r-rds"
    attr(x, "dataset_bibentry") <- be
    return(invisible(x))
  }

  # Treat these as non-user values we can safely replace without overwrite=TRUE
  is_default <- is.null(be$format) ||
    identical(be$format, "application/r-rds") ||
    identical(be$format, ":tba")

  if (is_default || overwrite) {
    be$format <- as.character(value)
  } else {
    message(
      "The dataset already has a format: ", be$format,
      ". Use overwrite = TRUE to replace it."
    )
  }

  attr(x, "dataset_bibentry") <- be
  invisible(x)
}
#' @title Get or Set the Title of a Dataset
#'
#' @description Retrieve or assign the main title of a dataset, typically used
#' as the primary label in metadata exports (e.g., DataCite or Dublin Core).
#'
#' @details According to the [Dublin Core specification for
#' `title`](https://www.dublincore.org/specifications/dublin-core/dcmi-terms/elements11/title/),
#' the title represents the name by which the resource is formally known.
#'
#' The DataCite metadata schema supports multiple titles (e.g., translated,
#' alternative), but this function currently supports only a single main title.
#'
#' @param x A dataset object created by [dataset_df()] or [as_dataset_df()].
#' @param value A character string representing the new title. If `NULL`, a
#'   placeholder value `":tba"` is assigned. If `value` is a character vector of
#'   length > 1, an error is raised.
#' @param overwrite Logical. If `TRUE`, the existing title is replaced. If
#'   `FALSE` (default) and a title is already present, a warning is issued and
#'   the title is not changed.
#'
#' @return `dataset_title()` returns the current dataset title as a character
#' string. `dataset_title<-()` returns the updated dataset object (invisible).
#'
#' @examples
#' dataset_title(orange_df)
#'
#' # Set a new title with overwrite = TRUE
#' dataset_title(orange_df, overwrite = TRUE) <- "The Growth of Orange Trees"
#' dataset_title(orange_df)
#'
#' @family bibliographic helper functions
#' @rdname dataset_title
#' @export

dataset_title <- function(x) {
  if (!is.dataset_df(x)) {
    stop("dataset_title(x) must be a dataset object created with dataset() or as_dataset_df().")
  }

  ds_bibentry <- get_bibentry(x)
  ds_bibentry$title
}

#' @rdname dataset_title
#' @importFrom stats setNames
#' @export
`dataset_title<-` <- function(x, overwrite = FALSE, value) {
  if (!is.dataset_df(x)) {
    stop("title(x) <- x must be a dataset object created with dataset() or as_dataset_df().")
  }

  ds_bibentry <- invisible(get_bibentry(x))

  if (is.null(value)) {
    ds_bibentry$title <- ":tba"
    attr(x, "dataset_bibentry") <- ds_bibentry
    return(x)
  }

  if (inherits(value, "factor") || inherits(value, "character")) {
    if (length(value) > 1) {
      stop("title(x) <- value: if you have multiple titles, use dataset_title_create()")
    }
  }

  if (!ds_bibentry$title %in% c(":unas", ":tba", "") && !overwrite) {
    warning("The dataset already has a title: ", ds_bibentry$title)
  } else {
    ds_bibentry$title <- value
  }

  attr(x, "dataset_bibentry") <- ds_bibentry

  invisible(x)
}
#' @title Dataset to triples (three columns or N-Triples)
#' @description Converts a dataset to RDF-style triples with subject, predicate,
#'   and object columns. Supports semantic expansion via variable metadata.
#' @param x A `dataset_df` or `data.frame`.
#' @param idcol Name or index of the subject column. If NULL, defaults to
#'   `"rowid"` or rownames.
#' @param expand_uri Logical; if TRUE, expands URIs using namespaces and
#'   definitions.
#' @param format Output format: `"data.frame"` (default) or `"nt"` for
#'   N-Triples.
#' @return Either a `data.frame` with columns `s`, `p`, and `o`, or a character
#'   vector of N-Triple lines.
#' @export
#' @details
#' For publishing examples, a minimal serverless scaffold is provided at
#' <https://github.com/dataobservatory-eu/dataset-template>, which shows how
#' to host CSV + RDF serialisations on GitHub Pages without any server setup.
#'
#' @note A simple, serverless scaffolding for publishing `dataset_df` objects
#'   on the web (with HTML + RDF exports) is available at
#'   <https://github.com/dataobservatory-eu/dataset-template>.
#'
#' @examples
#' # A minimal example with just rowid and geo
#' data("gdp", package = "dataset")
#' small_geo <- dataset_df(
#'   geo = defined(
#'     gdp$geo[1:3],
#'     label = "Geopolitical entity",
#'     concept = "http://example.com/prop/geo",
#'     namespace = "https://dd.eionet.europa.eu/vocabulary/eurostat/geo/$1"
#'   )
#' )
#'
#' # View as triple table
#' dataset_to_triples(small_geo)
#'
#' # View as N-Triples
#' dataset_to_triples(small_geo, format = "nt")
dataset_to_triples <- function(x,
                               idcol = NULL,
                               expand_uri = TRUE,
                               format = "data.frame") {
  is_dataset <- inherits(x, "dataset_df")
  if (!is_dataset) {
    stop("Works only with dataset_df objects.")
  }

  # Determine subject (s)
  if (is.null(idcol)) {
    if ("rowid" %in% names(x)) {
      idcol <- "rowid"
    } else {
      x <- cbind(rowid = row.names(x))
      idcol <- "rowid"
    }
  }

  idcol_pos <- idcol_find(x, idcol)
  data_cols <- setdiff(seq_along(x), idcol_pos)

  # Expand subject URIs using namespace
  s_vec <- as.character(x[[idcol]])
  ns <- tryCatch(var_namespace(x[[idcol]]), error = function(e) NULL)

  if (expand_uri && !is.null(ns) && nzchar(ns)) {
    if (grepl("\\$1", ns)) {
      s_vec <- vapply(s_vec, function(id) sub("\\$1", id, ns), character(1))
    } else {
      s_vec <- paste0(ns, s_vec)
    }
  }


  # Construct triple list
  triple_list <- lapply(data_cols, function(i) {
    triples_column_generate(s_vec, x[[i]], names(x)[i])
  })

  out <- do.call(rbind, triple_list)

  # Add metadata if available
  if (is_dataset) {
    attr(out, "bibentry") <- get_bibentry(x)
    attr(out, "title") <- paste0(dataset_title(x), " [triple form]")
    attr(out, "subject") <- subject(x)
  }

  row.names(out) <- NULL

  # Return either data.frame or N-Triples
  if (format %in% c("nt", "ntriples", "N-Triples")) {
    triples_to_ntriples(out)
  } else {
    out
  }
}

#' @title Internal: Expand multi-valued DC fields to RDF triples
#' @description Converts scalar or vector fields into RDF triples.
#' @param dataset_id The subject URI
#' @param predicate_uri The RDF predicate URI
#' @param values A scalar, character vector, or list (e.g., person objects)
#' @return A character vector of RDF triples
#' @keywords internal
expand_triples <- function(dataset_id, predicate_uri, values) {
  if (is.null(values)) {
    return(character(0))
  }

  # Ensure list for consistency
  if (!is.list(values)) values <- as.list(values)

  vapply(values, function(val) {
    if (inherits(val, "person")) {
      val <- format(val)
    }
    n_triple(dataset_id, predicate_uri, val)
  }, character(1))
}

#' @title Internal: Generate RDF triples for a single column
#' @description Create subject-predicate-object triples from one column of a dataset
#' @param s_vec A character vector of subject URIs (length = number of rows)
#' @param col The column vector (e.g., \code{x[[i]]})
#' @param colname The name of the column (used as fallback for predicate)
#' @return A data.frame with columns s, p, o
#' @keywords internal
triples_column_generate <- function(s_vec, col, colname) {
  def <- tryCatch(var_concept(col), error = function(e) NULL)
  ns <- tryCatch(var_namespace(col), error = function(e) NULL)

  # predicate: use definition or fallback
  pred_uri <- if (!is.null(def) && nzchar(def)) {
    def
  } else {
    paste0("http://example.com/prop/", colname)
  }

  # object: URI from namespace or typed literal via xsd_convert
  if (!is.null(ns) && nzchar(ns)) {
    o_val <- vapply(as.character(col), function(val) {
      if (grepl("\\$1", ns)) {
        sub("\\$1", val, ns)
      } else {
        paste0(ns, val)
      }
    }, character(1))
  } else {
    o_val <- xsd_convert(col)
  }

  data.frame(
    s = s_vec,
    p = rep(pred_uri, length(o_val)),
    o = o_val,
    stringsAsFactors = FALSE
  )
}


#' @title Internal: Convert triple data.frame to N-Triples format
#' @description Turns a data.frame with `s`, `p`, `o` columns into N-Triples strings.
#' @param df A data.frame with columns `s`, `p`, and `o`.
#' @return A character vector of N-Triple lines.
#' @keywords internal
triples_to_ntriples <- function(df) {
  stopifnot(all(c("s", "p", "o") %in% names(df)))
  vapply(seq_len(nrow(df)), function(i) {
    n_triple(df$s[i], df$p[i], df$o[i])
  }, character(1))
}
#' Create a semantically well-defined, labelled vector
#'
#' `defined()` constructs a vector enriched with semantic metadata such as a
#' label, unit of measurement, concept URI, and optional namespace.
#' These vectors behave like base R vectors but retain metadata during
#' subsetting, comparison, and printing.
#'
#' The resulting object inherits from [haven::labelled()] and integrates with
#' tidyverse workflows, enabling downstream conversion to RDF and other
#' standards.
#'
#' @param x A vector of type character, numeric, Date, factor, or a `labelled`
#'   object.
#' @param labels An optional named vector of value labels. Only a subset of
#'   values may be labelled.
#' @param label A short human-readable label (string of length 1).
#' @param unit Unit of measurement (e.g., "kg", "hours"). Must be a string of
#'   length 1 or `NULL`.
#' @param concept A URI or concept name representing the meaning of the
#'   variable.
#' @param namespace Optional string or named character vector, used for
#'   value-level URI expansion.
#' @param ... Reserved for future use.
#'
#' @return A vector of class `"defined"` (technically
#' `haven_labelled_defined`), which behaves like a standard vector with
#' additional semantic metadata and is inherited from [haven::labelled()].
#' @importFrom haven labelled
#' @importFrom labelled to_labelled is.labelled
#' @import vctrs
#' @importFrom utils head tail
#' @seealso `browseVignettes("dataset")`
#' @seealso [is.defined()], [as_numeric()], [as_character()], [as_factor()],
#'   [strip_defined()]
#'
#' @examples
#' gdp_vector <- defined(
#'   c(3897, 7365, 6753),
#'   label = "Gross Domestic Product",
#'   unit = "million dollars",
#'   concept = "http://data.europa.eu/83i/aa/GDP"
#' )
#'
#' # To check the s3 class of the vector:
#' is.defined(gdp_vector)
#'
#' # To print the defined vector:
#' print(gdp_vector)
#'
#' # To summarise the defined vector:
#' summary(gdp_vector)
#'
#' # Subsetting work as expected:
#' gdp_vector[1:2]
#' @export

defined <- function(x,
                    labels = NULL,
                    label = NULL,
                    unit = NULL,
                    concept = NULL,
                    namespace = NULL,
                    ...) {
  dots <- list(...)
  if (!is.null(dots$definition)) {
    warning("`definition` is deprecated; please use `concept` instead.", call. = FALSE)
    if (is.null(concept)) {
      concept <- dots$definition
    }
  }

  if (!is.null(unit) && (!is.character(unit) || length(unit) != 1)) {
    stop("`unit` must be a single character string or NULL", call. = FALSE)
  }
  if (!is.null(namespace) && (!is.character(namespace) || is.null(names(namespace)) && length(namespace) != 1)) {
    stop("`namespace` must be a named character vector or a single string", call. = FALSE)
  }

  if (is.numeric(x)) {
    x <- vctrs::vec_data(x)
    labels <- vec_cast_named(labels, x, x_arg = "labels", to_arg = "x")
    return(new_labelled_defined(x,
      labels = labels,
      label = label,
      unit = unit,
      concept = concept,
      namespace = namespace
    ))
  }

  if (is.character(x)) {
    return(new_labelled_defined(x,
      labels = labels,
      label = label,
      unit = unit,
      concept = concept,
      namespace = namespace
    ))
  }

  if (inherits(x, "Date")) {
    return(new_datetime_defined(x,
      label = label,
      unit = unit,
      concept = concept,
      namespace = namespace
    ))
  }

  if (is.factor(x)) {
    labelled_x <- to_labelled(x)
    var_unit(labelled_x) <- unit
    var_concept(labelled_x) <- concept
    var_namespace(labelled_x) <- namespace
    class(labelled_x) <- c("haven_labelled_defined", class(labelled_x))
    return(labelled_x)
  }

  if (is.labelled(x)) {
    var_unit(x) <- unit
    var_concept(x) <- concept
    var_namespace(x) <- namespace
    class(x) <- c("haven_labelled_defined", class(x))
    return(x)
  }

  stop("Unsupported input type to defined().", call. = FALSE)
}


#' @rdname defined
#' @export
is.defined <- function(x) {
  any(inherits(x, "haven_labelled_defined"), inherits(x, "datetime_defined"))
}

#' @keywords internal
vec_ptype_abbr.haven_labelled_defined <- function(x, ...) {
  "defined"
}

#' @keywords internal
vec_ptype2.double.haven_labelled_defined <- function(x, y, ...) double()

#' @keywords internal
vec_cast.double.haven_labelled_defined <- function(x, to, ...) vctrs::vec_data(x)

#' @keywords internal
vec_cast.character.haven_labelled_defined <- function(x, to, ...) vctrs::vec_data(x)

#' From haven
#' @keywords internal
#' @importFrom vctrs vec_cast
vec_cast_named <- function(x, to, ...) {
  stats::setNames(vctrs::vec_cast(x, to, ...), names(x))
}

#' @importFrom tibble new_tibble
#' @importFrom haven labelled
#' @keywords internal
new_labelled_defined <- function(x = double(),
                                 labels = NULL,
                                 label = NULL,
                                 unit = NULL,
                                 concept = NULL,
                                 namespace = NULL) {
  if (!is.null(unit) && (!is.character(unit) || length(unit) != 1)) {
    stop("defined(..., unit): 'unit' must be a character vector of length one.")
  }

  if (!is.null(concept) && (!is.character(concept) || length(concept) != 1)) {
    stop("defined(..., defintion): 'concept' must be a character vector of length one or NULL.")
  }

  if (!is.null(label) && (!is.character(label) || length(label) != 1)) {
    stop("defined(..., label): 'label' must be a character vector of length one or NULL.")
  }

  if (!is.null(namespace) && (!is.character(namespace) || length(namespace) != 1)) {
    stop("defined(..., namespace): 'namespace' must be a character vector of length one or NULL.")
  }

  tmp <- haven::labelled(x, labels = labels, label = label)

  attr(tmp, "unit") <- unit
  attr(tmp, "concept") <- concept
  attr(tmp, "namespace") <- namespace
  attr(tmp, "class") <- c("haven_labelled_defined", class(tmp))

  tmp
}

#' @importFrom tibble new_tibble
#' @keywords internal
new_datetime_defined <- function(x,
                                 label = NULL,
                                 unit = NULL,
                                 concept = NULL,
                                 namespace = NULL) {
  if (!is.null(unit) && (!is.character(unit) || length(unit) != 1)) {
    stop("defined(..., unit): 'unit' must be a character vector of length one.")
  }

  if (!is.null(concept) && (!is.character(concept) || length(concept) != 1)) {
    stop("defined(..., defintion): 'concept' must be a character vector of length one.")
  }

  if (!is.null(label) && (!is.character(label) || length(label) != 1)) {
    stop("defined(..., label): 'label' must be a character vector of length one.")
  }

  if (!is.null(namespace) && (!is.character(namespace) || length(namespace) != 1)) {
    stop("defined(..., namespace): 'namespace' must be a character vector of length one or NULL.")
  }

  tmp <- x

  attr(tmp, "unit") <- unit
  attr(tmp, "concept") <- concept
  attr(tmp, "namespace") <- namespace
  attr(tmp, "class") <- c("datetime_defined", class(tmp))

  tmp
}


## Subsetting ------------------------------------------------------

#' @export
`[.haven_labelled_defined` <- function(x, i, ...) {
  result <- NextMethod("[")
  most_attrs <- c("label", "unit", "concept", "namespace", "labels")
  for (attr_name in most_attrs) {
    attr(result, attr_name) <- attr(x, attr_name)
  }
  class(result) <- class(x)
  result
}

#' @export
#' @importFrom vctrs vec_data
`[[.haven_labelled_defined` <- function(x, i, ...) {
  defined(vctrs::vec_data(x)[[i]],
    label = var_label(x),
    unit = var_unit(x),
    concept = var_concept(x),
    namespace = var_namespace(x),
    labels = attr(x, "labels")
  )
}


#' @export
#' @importFrom vctrs vec_data
Ops.haven_labelled_defined <- function(e1, e2) {
  # Comparisons work as expected
  lhs <- if (inherits(e1, "haven_labelled_defined")) vctrs::vec_data(e1) else e1
  rhs <- if (inherits(e2, "haven_labelled_defined")) vctrs::vec_data(e2) else e2
  .Generic <- .Generic
  do.call(.Generic, list(lhs, rhs))
}

#' @export
#' @importFrom vctrs vec_data
length.haven_labelled_defined <- function(x) {
  length(vctrs::vec_data(x))
}

#' @export
#' @importFrom vctrs vec_data
head.haven_labelled_defined <- function(x, n = 6L, ...) {
  x[seq_len(min(n, length(x)))]
}

#' @export
#' @importFrom vctrs vec_data
tail.haven_labelled_defined <- function(x, n = 6L, ...) {
  x[seq.int(to = length(x), length.out = min(n, length(x)))]
}


## Print & Summary --------------------------------------------------

#' @export
print.haven_labelled_defined <- function(x, ...) {
  has_def <- !is.null(var_concept(x)) && !is.na(var_concept(x)) && nzchar(var_concept(x))
  has_unit <- !is.null(var_unit(x)) && !is.na(var_unit(x)) && nzchar(var_unit(x))
  has_label <- !is.null(var_label(x))

  cat(deparse(substitute(x)))

  if (has_label) cat(paste0(": ", var_label(x)))
  cat("\n")

  if (has_def && has_unit) {
    msg <- paste0("Defined as ", var_concept(x), ", measured in ", var_unit(x))
  } else if (has_def) {
    msg <- paste0("Defined as ", var_concept(x))
  } else if (has_unit) {
    msg <- paste0("Measured in ", var_unit(x))
  } else {
    msg <- "Defined vector"
  }

  cat(msg, "\n")
  print(vctrs::vec_data(x), ...)
  invisible(x)
}


#' @export
format.haven_labelled_defined <- function(x, ...) {
  base <- format(vec_data(x), ...)
  unit <- var_unit(x)
  def <- var_concept(x)

  if (!is.null(unit) && nzchar(unit)) {
    suffix <- paste0(" (", unit, ")")
  } else if (!is.null(def) && nzchar(def) && nchar(def) < 30) {
    suffix <- paste0(" [", def, "]")
  } else {
    suffix <- ""
  }

  paste0(base, suffix)
}

#' @rdname defined
#' @param object An R object to be summarised.
#' @export
summary.haven_labelled_defined <- function(object, ...) {
  label <- var_label(object)
  unit <- var_unit(object)

  if (!is.null(label) && nzchar(label)) {
    if (!is.null(unit) && nzchar(unit)) {
      cat(paste0(label, " (", unit, ")\n"))
    } else {
      cat(paste0(label, "\n"))
    }
  }
  NextMethod()
}

#' Combine defined vectors with metadata checks
#'
#' The `c()` method for `defined` vectors ensures that all semantic metadata
#' (label, unit, concept, namespace, and value labels) match exactly. This
#' prevents accidental loss or mixing of incompatible definitions during
#' concatenation.
#'
#' All input vectors must:
#' - Have identical `label` attributes
#' - Have identical `unit`, `concept`, and `namespace`
#' - Have identical value labels (or none)
#'
#' @param ... One or more vectors created with [defined()].
#'
#' @return A single `defined` vector with concatenated values and retained
#'   metadata.
#'
#' @examples
#' a <- defined(1:3, label = "Length", unit = "meter")
#' b <- defined(4:6, label = "Length", unit = "meter")
#' c(a, b)
#'
#' @seealso [defined()]
#' @export
c.haven_labelled_defined <- function(...) {
  dots <- list(...)

  var_labels <- unlist(lapply(dots, var_label))
  val_labels <- lapply(dots, function(x) attr(x, "labels"))
  units <- unlist(lapply(dots, var_unit))
  concepts <- unlist(lapply(dots, var_concept))
  namespaces <- unlist(lapply(dots, namespace_attribute))

  all_identical <- function(l) {
    all(mapply(identical, head(l, 1), tail(l, -1)))
  }

  if (length(unique(as.character(var_labels))) > 1) {
    stop("c(): var_label must be identical or NULL across inputs")
  }

  if (length(unique(as.character(units))) > 1) {
    stop("c(): unit must be identical or NULL across inputs")
  }

  if (length(unique(as.character(concepts))) > 1) {
    stop("c(): concept must be identical or NULL across inputs")
  }

  if (length(unique(as.character(namespaces))) > 1) {
    stop("c(): namespace must be identical or NULL across inputs")
  }

  if (!all_identical(val_labels)) {
    stop("c(): value labels must be identical or NULL across inputs")
  }

  defined(
    unname(do.call(c, lapply(dots, vctrs::vec_data))),
    label = var_labels[[1]],
    labels = val_labels[[1]],
    concept = concepts[[1]],
    namespace = namespaces[[1]],
    unit = units[[1]]
  )
}

## Coercion ----------------------------------------------------------
## as_numeric, as_character, as_factor in separate files

#' @export
as.list.haven_labelled_defined <- function(x, ...) {
  lapply(seq_along(x), function(i) x[[i]])
}

#' @export
as.vector.haven_labelled_defined <- function(x, mode = "any") {
  as.vector(vctrs::vec_data(x), mode = mode)
}

#' @title Strip the class from a defined vector
#' @description Converts a `defined` vector to a base R numeric or character,
#'   retaining metadata as passive attributes.
#' @param x A `defined` vector.
#' @return A base R vector with attributes (`label`, `unit`, etc.) intact.
#' @seealso [as_numeric()], [as_character()]
#' @examples
#' gdp <- defined(c(3897L, 7365L), label = "GDP", unit = "million dollars")
#' strip_defined(gdp)
#'
#' fruits <- defined(c("apple", "avocado", "kiwi"),
#'   label = "Fruit", unit = "kg"
#' )
#'
#' strip_defined(fruits)
#' @export
strip_defined <- function(x) {
  if (!inherits(x, "haven_labelled_defined")) {
    return(x)
  }

  base_class <- typeof(vctrs::vec_data(x)) # typically "double" or "integer"
  class(x) <- base_class
  x
}

#' @importFrom pillar type_sum tbl_sum
#' @export
type_sum.haven_labelled_defined <- function(x) {
  "defined"
}
#' @title Describe a dataset in N-Triples format
#' @description Writes provenance and Dublin Core metadata of a dataset to a
#'   file or connection in N-Triples format.
#' @param x A `dataset_df` object.
#' @param con A connection or a character string path (e.g. from `tempfile()`).
#' @return Writes N-Triples to `con` and invisibly returns `x`.
#' @examples
#' test_ds <- dataset_df(
#'   rowid = defined(c("eg:1", "eg:2"),
#'     namespace = "http://example.com/dataset#"
#'   ),
#'   geo = defined(
#'     gdp$geo[1:2],
#'     label = "Country",
#'     concept = "http://example.com/prop/geo",
#'     namespace = "https://eionet.europa.eu/geo/$1"
#'   ),
#'   dataset_bibentry = dublincore(
#'     title = "Example Dataset",
#'     creator = person("John", "Doe")
#'   )
#' )
#'
#' # returns invisibly the contents of the text file serialisation:
#' testdescription <- describe(test_ds, con = tempfile())
#' testdescription
#' @export
describe <- function(x, con) {
  assertthat::assert_that(
    is.dataset_df(x),
    msg = "describe(x, con): x must be a dataset_df object."
  )

  # Collect provenance and DC metadata
  prov_text <- provenance(x)
  dc_text <- as_dublincore(x, type = "ntriples")

  prov_text <- if (is.null(prov_text)) character(0) else as.character(prov_text)
  dc_text <- if (is.null(dc_text)) character(0) else as.character(dc_text)

  ntriples_text <- c(prov_text, dc_text)

  if (!is.character(ntriples_text)) {
    stop("describe(): expected character vector of N-Triples.")
  }

  # Handle connection or file path
  if (is.character(con)) {
    con_file <- file(con, open = "w", encoding = "UTF-8")
    on.exit(close(con_file), add = TRUE)
    writeLines(ntriples_text, con = con_file)
  } else {
    writeLines(ntriples_text, con = con)
  }

  invisible(x)
}
#' @title Get or set the dataset Description
#'
#' @description Get or set the optional `Description` property as an attribute
#'   on a dataset object.
#'
#' @details The `Description` is recommended for discovery in DataCite. It
#'   captures additional information that does not fit other metadata categories
#'   — such as technical notes or dataset usage. It is a free-text field. See
#'   [dct:description](https://www.dublincore.org/specifications/dublin-core/dcmi-terms/elements11/description/).
#'
#' @param x A dataset object created with [`dataset_df()`] or
#'   [`as_dataset_df()`].
#' @param value The new description, as a character string.
#' @param overwrite Logical. If `TRUE`, will overwrite any existing description.
#'   If `FALSE` (default), will warn and keep the existing description.
#'
#' @return The `Description` attribute as a character vector of length 1.
#'
#' @examples
#' description(orange_df)
#' description(orange_df, overwrite = TRUE) <- "This dataset records orange tree growth."
#' description(orange_df)
#'
#' @family bibliographic helper functions
#' @export

description <- function(x) {
  assert_that(is.dataset_df(x),
    msg = "description(x): x must be a dataset object created with dataset_df() or as_dataset_df()."
  )

  ds_bibentry <- get_bibentry(x)
  as.character(ds_bibentry$description)
}

#' @rdname description
#' @export
`description<-` <- function(x, overwrite = FALSE, value) {
  assert_that(is.dataset_df(x),
    msg = "description(x) <- value: x must be a dataset object created with dataset_df() or as_dataset_df()."
  )

  ds_bibentry <- get_bibentry(x)
  existing_description <- as.character(ds_bibentry$description)

  if (is.null(value)) {
    value <- ":unas"
  }

  if (overwrite ||
    length(existing_description) == 0 ||
    existing_description %in% c("", ":unas", ":tba")) {
    ds_bibentry$description <- as.character(value)
    attr(x, "dataset_bibentry") <- ds_bibentry
  } else {
    warning(
      "The dataset already has a description: ",
      existing_description, "."
    )
  }
  invisible(x)
}
#' Add or Retrieve Dublin Core Metadata
#'
#' Adds or retrieves metadata conforming to the
#' [Dublin Core Metadata Terms](https://www.dublincore.org/specifications/dublin-core/dcmi-terms/)
#' standard, enabling consistent and structured citation and retrieval of R
#' dataset objects.
#'
#' @details
#' The Dublin Core Metadata Element Set (DCMES) is a standardized vocabulary for
#' describing digital and physical resources. It includes 15 core fields and is
#' formally standardized as ISO 15836, IETF RFC 5013, and ANSI/NISO Z39.85.
#'
#' This function constructs a [utils::bibentry()] object extended with DCMI
#' terms and is compatible with [dataset_df()] objects. The resulting metadata
#' can be used for semantic documentation and machine-readable citation.
#'
#' For compatibility with [utils::bibentry()], the `dataset_date` parameter is
#' automatically used to derive both `publication_date` and `year` fields.
#'
#' @param x An object to annotate. Typically a `data.frame`, `tibble`,
#'   or named list; can be added with [set_bibentry()] to a semantically
#'   rich `dataset_df`.
#' @param title A name given to the resource. See [dataset_title()].
#' @param creator One or more [utils::person()] objects representing the
#'   creator(s). See [creator()].
#' @param contributor Additional contributors ([utils::person()]) with optional
#'   roles. See [contributor()].
#' @param publisher A character or [utils::person()] indicating the publishing
#'   entity. See [publisher()].
#' @param dataset_date A publication or release date (`Date`, `POSIXct`, or
#'   character in `YYYY`, `YYYY-MM-DD`, or ISO format).
#' @param year An explicit publication year. If omitted, inferred from
#'   `dataset_date`.
#' @param identifier A unique persistent identifier (e.g., DOI). See [identifier()].
#' @param subject A keyword or controlled vocabulary term. See [subject()] and
#'   [subject_create()].
#' @param description A free-text summary of the dataset. See [description()].
#' @param language ISO 639-1 language code. See [language()].
#' @param rights A string describing intellectual property or usage rights.
#' Use a URI like `"https://creativecommons.org/public-domain/cc0/"`.
#' @param dataset_format The technical format of the dataset (e.g., MIME type).
#' See [dataset_format()].
#' @param relation A related resource (e.g., version, paper, or parent dataset).
#'   Currently only supports an URI, for example,
#'   `"https:://doi.org/10.32614/CRAN.package.dataset"`.
#' @param datasource A URL or label for the original source of the dataset.
#' @param coverage Geographic or temporal extent (spatial/temporal coverage).
#' @param type The resource type. For datasets, use `"Dataset"`. See
#'   [DCMI Type Vocabulary](https://www.dublincore.org/specifications/dublin-core/dcmi-type-vocabulary/).
#' @param ... Additional metadata fields.
#'
#' @return
#' A `bibentry` object extended with class `"bibrecord"`, storing structured
#' Dublin Core metadata. Use [as_dublincore()] to extract the metadata in list,
#' tabular, or RDF form.
#'
#' @source
#' - [DCMI Metadata Terms](https://www.dublincore.org/specifications/dublin-core/dcmi-terms/)
#'
#' @importFrom utils person bibentry
#'
#' @examples
#' orange_bibentry <- dublincore(
#'   title = "Growth of Orange Trees",
#'   creator = c(
#'     person(
#'       given = "N.R.",
#'       family = "Draper",
#'       role = "cre",
#'       comment = c(VIAF = "http://viaf.org/viaf/84585260")
#'     ),
#'     person(given = "H", family = "Smith", role = "cre")
#'   ),
#'   contributor = person(given = "Antal", family = "Daniel", role = "dtm"),
#'   publisher = "Wiley",
#'   datasource = "https://isbnsearch.org/isbn/9780471170822",
#'   dataset_date = 1998,
#'   identifier = "https://doi.org/10.5281/zenodo.14917851",
#'   language = "en",
#'   description = "The Orange data frame has 35 rows and 3 columns of records
#'                  of the growth of orange trees."
#' )
#'
#' # To inspect structured metadata from a dataset_df object:
#' as_dublincore(orange_df, type = "list")
#'
#' @export
#' @seealso
#' Learn more in the vignette:
#' [`bibrecord`](https://dataset.dataobservatory.eu/articles/bibrecord.html)
#' @family bibrecord functions

dublincore <- function(
    title,
    creator,
    contributor = NULL,
    year = NULL,
    publisher = NULL,
    identifier = NULL,
    subject = NULL,
    type = "DCMITYPE:Dataset",
    dataset_date = NULL,
    language = NULL,
    relation = NULL,
    dataset_format = "application/r-rds",
    rights = NULL,
    datasource = NULL,
    description = NULL,
    coverage = NULL) {
  if (missing(creator) || is.null(creator)) {
    stop("dublincore(): A valid `creator` (as person or list of person) is required.")
  }

  if (inherits(creator, "person")) {
    creator <- list(creator)
  }

  if (length(title) != 1) {
    stop("dublincore(): title must be a single character string.")
  }

  creators <- normalize_roles(creator, default_role = "cre")

  dataset_date <- ifelse(is.null(dataset_date), ":tba", as.character(dataset_date))
  identifier <- ifelse(is.null(identifier), ":tba", as.character(identifier))
  dataset_format <- ifelse(is.null(dataset_format), "application/r-rds", as.character(dataset_format))
  if (is.null(relation)) {
    relation <- ":unas"
  }
  rights <- ifelse(is.null(rights), ":tba", as.character(rights))
  coverage <- ifelse(is.null(coverage), ":unas", as.character(coverage))
  datasource <- ifelse(is.null(datasource), ":unas", as.character(datasource))
  publishers <- if (is.null(publisher)) ":unas" else publisher
  contributor <- if (is.null(contributor)) NULL else contributor
  creators <- if (is.null(creator)) creators <- ":tba" else creators <- creator
  year <- if (!is.null(dataset_date)) substr(as.character(dataset_date), 1, 4) else NULL

  publisher <- fix_publisher(publishers = publishers)

  new_dublincore(
    title = title,
    creator = creators,
    identifier = identifier,
    publisher = publisher,
    subject = subject,
    type = type,
    contributor = contributor,
    dataset_date = dataset_date,
    year = year,
    language = language,
    relation = relation,
    dataset_format = dataset_format,
    rights = rights,
    datasource = datasource,
    description = description,
    coverage = coverage
  )
}


#' @keywords internal
new_dublincore <- function(title,
                           creator,
                           identifier = NULL,
                           publisher = NULL,
                           subject = NULL,
                           type = "DCMITYPE:Dataset",
                           contributor = NULL,
                           dataset_date = NULL,
                           year = NULL,
                           language = NULL,
                           relation = NULL,
                           dataset_format = NULL,
                           rights = NULL,
                           datasource = NULL,
                           description = NULL,
                           coverage = NULL) {
  year <- if (!is.null(dataset_date)) {
    substr(as.character(dataset_date), 1, 4)
  } else {
    NULL
  }

  # flatten relation for bibrecord
  relation_flat <- if (is.related(relation)) {
    relation$relatedIdentifier
  } else {
    relation
  }

  dublincore_object <- bibrecord(
    title       = title,
    author      = creator,
    identifier  = identifier,
    publisher   = publisher,
    subject     = if (is.subject(subject)) subject$term else as.character(subject),
    type        = type,
    contributor = contributor,
    date        = dataset_date,
    year        = year,
    language    = language,
    relation    = relation_flat,
    format      = dataset_format,
    rights      = rights,
    datasource  = datasource,
    description = description,
    coverage    = coverage
  )

  # preserve structured subject
  if (!is.null(subject) && is.subject(subject)) {
    attr(dublincore_object, "subject") <- subject
  }

  # preserve structured relation
  if (!is.null(relation) && is.related(relation)) {
    attr(dublincore_object, "relation") <- relation
  }

  if (!is.null(contributor)) {
    attr(dublincore_object, "contributor") <- contributor
  }

  class(dublincore_object) <- c("dublincore", class(dublincore_object))
  dublincore_object
}


#' @rdname dublincore
#'
#' @description
#' `is.dublincore()` checks whether an object inherits from the `"dublincore"`
#' class.
#'
#' @param x An object to test.
#'
#' @return
#' A logical value: `TRUE` if `x` is a Dublin Core metadata record (i.e.,
#' inherits from `"dublincore"`), otherwise `FALSE`.
#'
#' @export
is.dublincore <- function(x) {
  inherits(x, "dublincore")
}

#' @rdname dublincore
#' @exportS3Method
print.dublincore <- function(x, ...) {
  cat("Dublin Core Metadata Record\n")
  cat("--------------------------\n")

  pr <- function(label, value) {
    if (!is.null(value) && length(value) > 0 && any(nzchar(value))) {
      cat(sprintf("%-12s %s\n", paste0(label, ":"), paste(value, collapse = "; ")))
    }
  }

  pr("Title", x$title)
  pr("Creator(s)", paste(format(x$author), collapse = "; "))

  contributor <- attr(x, "contributor")
  if (!is.null(contributor)) {
    pr("Contributor(s)", fix_contributor(contributor))
  }

  subj <- attr(x, "subject")
  if (!is.null(subj) && is.subject(subj)) {
    subj_val <- subj$term
    if (!is.null(subj$schemeURI) && nzchar(subj$schemeURI)) {
      subj_val <- paste0(subj_val, " [", subj$schemeURI, "]")
    }
    pr("Subject(s)", subj_val)
  } else if (!is.null(x$subject)) {
    pr("Subject(s)", x$subject)
  }

  pr("Publisher", x$publisher)
  pr("Year", x$year)
  pr("Language", x$language)
  pr("Description", x$description)

  invisible(x)
}
#' @keywords internal
dublincore_to_triples <- function(
    dclist,
    dataset_id = "http://example.com/dataset") {
  if (is.null(dclist) || is.null(dclist$title) || nchar(dclist$title) == 0) {
    stop("Error: dublincore_to_triples(dclist, dataset_id): no title found in dclist")
  }

  # Normalize type field URI if needed
  if (!is.null(dclist$type)) {
    dclist$type <- gsub("DCMITYPE:", "http://purl.org/dc/terms/DCMIType", dclist$type)
  }

  # Accumulate all triples (many Dublin Core fields may have multiple values):
  dctriples <- c(
    expand_triples(dataset_id, "http://purl.org/dc/terms/title", dclist$title),
    expand_triples(dataset_id, "http://purl.org/dc/terms/description", dclist$description),
    expand_triples(dataset_id, "http://purl.org/dc/terms/creator", dclist$creator),
    expand_triples(dataset_id, "http://purl.org/dc/terms/contributor", dclist$contributor),
    expand_triples(dataset_id, "http://purl.org/dc/terms/publisher", dclist$publisher),
    expand_triples(dataset_id, "http://purl.org/dc/terms/identifier", dclist$identifier),
    expand_triples(dataset_id, "http://purl.org/dc/terms/subject", dclist$subject),
    expand_triples(dataset_id, "http://purl.org/dc/terms/type", dclist$type),
    expand_triples(dataset_id, "http://purl.org/dc/terms/date", dclist$date),
    expand_triples(dataset_id, "http://purl.org/dc/terms/language", dclist$language),
    expand_triples(dataset_id, "http://purl.org/dc/terms/relation", dclist$relation),
    expand_triples(dataset_id, "http://purl.org/dc/terms/format", dclist$format),
    expand_triples(dataset_id, "http://purl.org/dc/terms/rights", dclist$rights),
    expand_triples(dataset_id, "http://purl.org/dc/terms/source", dclist$datasource),
    expand_triples(dataset_id, "http://purl.org/dc/terms/coverage", dclist$coverage)
  )

  n_triples(dctriples)
}
#' Format contributors into a citation string
#'
#' Format a list of `utils::person` objects into a compact string, merging roles
#' per person and normalizing names. Contributors without explicit roles are
#' assigned `"ctb"`. If `NULL` or `":unas"` is supplied, returns `":unas"`.
#'
#' @param contributors A vector or list of `person` objects, or `NULL`, or the
#'   character string `":unas"`.
#'
#' @return A single character string, e.g. `"{Jane Doe [dtm, ctb]} and
#'  {John Smith [ctb]}"`.
#' @keywords internal
fix_contributor <- function(contributors = NULL) {
  if (is.null(contributors) ||
    (is.character(contributors) &&
      length(contributors) == 1 &&
      contributors == ":unas")) {
    return(":unas")
  }

  # Normalize into list of persons
  if (inherits(contributors, "person")) {
    contributors_list <- as.list(contributors)
  } else if (is.list(contributors) && all(vapply(contributors, inherits, "person", FUN.VALUE = logical(1)))) {
    contributors_list <- contributors
  } else {
    return(":unas")
  }

  # Group by identity (given|family)
  identity_keys <- vapply(contributors_list, function(p) {
    paste0(p$given %||% "", "|", p$family %||% "")
  }, character(1))

  merged <- vapply(unique(identity_keys), function(key) {
    matches <- contributors_list[identity_keys == key]

    # Collect unique roles (default to ctb)
    roles <- unique(unlist(lapply(matches, function(p) {
      if (is.null(p$role) || length(p$role) == 0 || all(!nzchar(p$role))) {
        "ctb"
      } else {
        p$role
      }
    })))

    base <- matches[[1]]
    full_name <- clean_person_name(base)
    paste0("{", full_name, " [", paste(roles, collapse = ", "), "]}")
  }, character(1))

  paste(merged, collapse = " and ")
}

#' Remove role suffixes from formatted person names
#'
#' @param p A `person` object.
#'
#' @return Character string without role annotations, e.g. `"Jane Doe"`.
#' @keywords internal
clean_person_name <- function(p) {
  name <- format(p)
  sub("\\s*\\[[^]]+\\]$", "", name)
}

#' Map R person roles to schema.org-style roles
#'
#' @param role A character vector of roles (e.g. `"cre"`, `"ctb"`).
#'
#' @return A character vector with schema.org-style roles.
#' @keywords internal
map_role_to_schema <- function(role) {
  role_map <- c(
    cre = "creator",
    aut = "author",
    ctb = "contributor",
    dtm = "editor",
    fnd = "funder",
    cph = "copyrightHolder",
    own = "copyrightHolder",
    pbl = "publisher"
  )
  ifelse(role %in% names(role_map), role_map[role], "contributor")
}
#' @keywords internal
fix_publisher <- function(publishers) {
  if (is.null(publishers)) {
    return(":unas")
  }

  if (inherits(publishers, "person")) {
    full_names <- vapply(as.list(publishers), function(p) {
      if (!is.null(p$family) && nzchar(p$family)) {
        paste(p$given, p$family)
      } else {
        p$given
      }
    }, character(1))

    if (length(full_names) > 1) {
      return(paste0("{", paste(full_names, collapse = "} and {"), "}"))
    } else {
      return(full_names)
    }
  }

  if (is.character(publishers)) {
    return(publishers)
  }

  stop("fix_publisher(): Unsupported publisher type")
}
#' @title Get or Set the Geolocation of a Dataset Object
#'
#' @description
#' Access or assign the optional `geolocation` attribute to a semantically rich
#' dataset object.
#'
#' @details
#' The `geolocation` field describes the spatial region or named place where
#' the data was collected or that the dataset is about. This field is
#' recommended for data discovery in DataCite Metadata Schema 4.4.
#'
#' See: [DataCite: Geolocation Guidance](https://support.datacite.org/docs/datacite-metadata-schema-v44-recommended-and-optional-properties#18-geolocation)
#'
#' @param x A dataset object created by [dataset_df()] or
#'   `dataset::as_dataset_df()`.
#' @param value A character string specifying the `geolocation`.
#' @param overwrite Logical. If `TRUE` (default), the existing `geolocation`
#'   attribute is replaced with `value`. If `FALSE`, the function returns a
#'   message and does not overwrite the existing value.
#'
#' @return A character string of length 1, representing the `geolocation`
#'   attribute attached to `x`.
#'
#' @examples
#' orange_dataset <- orange_df
#' geolocation(orange_df) <- "US"
#' geolocation(orange_df)
#'
#' geolocation(orange_df, overwrite = FALSE) <- "GB"
#'
#' @family bibliographic helper functions
#' @export

geolocation <- function(x) {
  attr(x, "Geolocation")
}

#' @rdname geolocation
#' @export
`geolocation<-` <- function(x, overwrite = TRUE, value) {
  if (is.null(attr(x, "Geolocation"))) {
    if (is.null(value)) {
      attr(x, "Geolocation") <- NA_character_
    } else {
      attr(x, "Geolocation") <- value
    }
  } else if (overwrite) {
    attr(x, "Geolocation") <- value
  } else {
    message("The dataset has already an Geolocation: ", geolocation(x))
  }
  x
}
#' @title Get or set the bibentry
#'
#' @description
#' Retrieve or replace the bibliographic entry stored in a dataset's attributes.
#' The entry is a [`utils::bibentry`] used to hold citation metadata for
#' [`dataset_df()`] objects.
#'
#' @details
#' New datasets are initialized with reasonable defaults. To build a new
#' bibentry with sensible defaults and field names, use [datacite()] (DataCite)
#' or [dublincore()] (Dublin Core), then assign it with
#' `set_bibentry(dataset) <- value`.
#'
#' See the vignette for more background:
#' `vignette("bibentry", package = "dataset")`.
#'
#' @param dataset A dataset created with [dataset_df()].
#' @param value A [`utils::bibentry`] to store on the dataset. If `NULL`, a
#'   minimal default entry is created.
#'
#' @return
#' * `get_bibentry(dataset)` returns the [`utils::bibentry`] stored in
#'   `dataset`'s attributes.
#' * `set_bibentry(dataset) <- value` sets the attribute and returns the
#'   modified dataset invisibly.
#'
#' @examples
#' # Get the bibentry of a dataset_df object:
#' be <- get_bibentry(orange_df)
#'
#' # Create a well-formed bibentry (DataCite-style):
#' be2 <- datacite(
#'   Creator = person("Jane", "Doe"),
#'   Title = "The Orange Trees Dataset",
#'   Publisher = "MyOrg"
#' )
#'
#' # Assign the new bibentry:
#' set_bibentry(orange_df) <- be2
#'
#' # Inspect in different notations:
#' as_datacite(orange_df, type = "list")
#' as_dublincore(orange_df, type = "list")
#'
#' @family bibliographic helper functions
#' @importFrom utils bibentry person
#' @export
get_bibentry <- function(dataset) {
  assertthat::assert_that("dataset_bibentry" %in% names(attributes(dataset)),
    msg = "Error: get_bibentry(dataset): dataset has no dataset_bibentry attribute"
  )
  attr(dataset, "dataset_bibentry")
}

#' @rdname get_bibentry
#' @export
`set_bibentry<-` <- function(dataset, value) {
  sys_time <- Sys.time()
  year <- substr(as.character(sys_time), 1, 4)

  if (is.null(value)) {
    value <- dublincore(
      title = "Untitled Dataset",
      creator = person("Unknown Author"),
      dataset_date = year
    )
  }

  if (is.null(value$year)) value$year <- year

  attr(dataset, "dataset_bibentry") <- value
  invisible(dataset)
}

#' @keywords internal
set_default_bibentry <- function() {
  sys_time <- Sys.time()
  year <- substr(as.character(sys_time), 1, 4)
  Title <- "Untitled Dataset"
  Creator <- person("Unknown", "Author")
  datacite(Title = Title, Creator = Creator, PublicationYear = year)
}
#' Add Identifier to First Column of a Dataset
#'
#' Adds a prefixed identifier (e.g., `eg:`) to the first column of a dataset,
#' useful for generating semantic row IDs (e.g., for RDF serialization).
#'
#' @param x A dataset created with [dataset_df()], or a regular data frame.
#' @param prefix A character string used as the prefix for row identifiers.
#'   Defaults to `"eg:"` (referring to [example.com](https://example.com)).
#' @param ids Optional. A character vector of custom IDs to use instead of row names.
#'
#' @return
#' A dataset of the same class as `x`, with the first column updated to include
#' unique prefixed identifiers.
#'
#' @examples
#' # Example with a dataset_df object:
#' id_to_column(orange_df)
#'
#' # Example with a regular data.frame:
#' id_to_column(Orange, prefix = "orange:")
#'
#' @export
id_to_column <- function(x, prefix = "eg:", ids = NULL) {
  is_dataset <- is.dataset_df(x)

  lastcol <- ncol(x)

  if (is.null(ids)) {
    ids <- gsub("[^[:alnum:]]", "-", row.names(x))
  } else if (nrow(x) != length(ids)) {
    stop("id_to_column(x, ..., ids) : ids must be of same lengths as nrow(x).")
  }

  if (is.null(prefix)) {
    prefix <- ""
  }

  if ("rowid" %in% names(x)) {
    x$rowid <- paste0(prefix, ids)
    return(x)
  } else {
    rhs <- x
    x$rowid <- paste0(prefix, ids)
    lhs <- x[, "rowid", drop = FALSE]

    if (is_dataset) {
      DataBibentry <- get_bibentry(rhs)
      dataset_subject <- subject(rhs)
      dataset_prov <- provenance(x)
      tmp <- as_dataset_df(cbind(lhs, rhs),
        reference = list(
          author = DataBibentry$author,
          title = DataBibentry$title
        )
      )
      attr(tmp, "dataset_bibentry") <- DataBibentry
      attr(tmp, "prov") <- dataset_prov
      subject(tmp) <- dataset_subject
    } else {
      tmp <- cbind(lhs, rhs)
    }
  }

  tmp
}
#' @title Get or Set the Identifier of a Dataset or Metadata Record
#'
#' @description Retrieve or assign the `identifier` attribute of a dataset or
#' bibliographic metadata object.
#'
#' @details An *identifier* provides an unambiguous reference to a resource.
#' Recommended practice is to supply a persistent identifier string, such as a
#' DOI, ISBN, or URN, that conforms to a recognized identification system.
#'
#' Both [Dublin
#' Core](https://www.dublincore.org/specifications/dublin-core/dcmi-terms/#identifier)
#' and [DataCite
#' 4.4](https://support.datacite.org/docs/datacite-metadata-schema-v44-mandatory-properties#1-identifier)
#' define `identifier` as a core property. If the identifier is a DOI, it will
#' also be stored in the `doi` field of the metadata record.
#'
#' Although `identifier` is not part of the minimal Dublin Core term set, it is
#' always included in `dataset` metadata for compatibility with publishing and
#' indexing systems. You may omit it if working under a strict DC profile.
#'
#' For best practice in choosing identifier schemes, see the [IANA-registered
#' URI schemes](https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml).
#'
#' @param x A [dataset_df()] object or a [`utils::bibentry`] object (including
#'   [dublincore()] or [datacite()] records).
#' @param value A character string giving the identifier. Can be named (e.g.,
#'   `c(doi = "...")`) or unnamed. Numeric values are coerced to character.
#' @param overwrite Logical. If `TRUE` (default), any existing identifier is
#'   replaced. If `FALSE`, an existing identifier is preserved unless it is
#'   `":unas"` or `":tba"`.
#'
#' @return For `identifier()`, the current identifier as a character string. For
#' `identifier<-()`, the updated object (invisible).
#'
#' @examples
#' orange_copy <- orange_df
#'
#' # Get the current identifier
#' identifier(orange_copy)
#'
#' # Set a new identifier (e.g., a DOI)
#' identifier(orange_copy) <- "https://doi.org/10.9999/example.doi"
#'
#' # Prevent accidental overwrite
#' identifier(orange_copy, overwrite = FALSE) <- "https://example.org/id"
#'
#' # Use numeric and NULL values
#' identifier(orange_copy) <- 12345
#' identifier(orange_copy) <- NULL # Sets ":unas"
#'
#' @family Reference metadata functions
#' @rdname identifier
#' @export

identifier <- function(x) {
  if (!(inherits(x, "bibentry") || inherits(x, "dataset_df"))) {
    stop("identifier(x): x must be a dataset_df or a bibentry object.")
  }

  if (is.dataset_df(x)) {
    ds_bibentry <- get_bibentry(x)
  } else {
    ds_bibentry <- x
  }

  ds_bibentry$identifier
}

#' @rdname identifier
#' @export
`identifier<-` <- function(x, overwrite = TRUE, value) {
  if (is.numeric(value)) value <- as.character(value)

  if (!(inherits(x, "bibentry") || inherits(x, "dataset_df"))) {
    stop("identifier(x): x must be a dataset_df or a bibentry object.")
  }

  if (!(is.null(value) || inherits(value, "character"))) {
    stop("identifier(x) <- value: value must be a named or not named character string of length 1.")
  }

  if (is.dataset_df(x)) {
    ds_bibentry <- get_bibentry(x)
  } else {
    ds_bibentry <- x
  }

  old_identifier <- ds_bibentry$identifier

  if (is.null(value)) {
    value <- ":unas"
  }

  is_doi <- function(i) {
    if (!is.null(names(i))) {
      if (tolower(names(i)) == "doi") {
        return(TRUE)
      }
    } else {
      ifelse(grepl("https://doi.org", i), TRUE, FALSE)
    }
  }

  if (overwrite || old_identifier %in% c(":unas", ":tba")) {
    ds_bibentry$identifier <- value
    if (is_doi(value)) {
      doi <- gsub("https://doi.org/", "", value)
      doi <- gsub("/$", "", doi)
      ds_bibentry$doi <- doi
    }
  } else {
    warning(
      "The dataset has already an identifier: ",
      old_identifier, ".\nYou can overwrite this message with identifier(x, overwrite = TRUE) <- value"
    )
  }

  if (inherits(x, "bibentry")) {
    ds_bibentry
  } else {
    if (is_doi(value)) attr(x, "doi") <- gsub("https://doi.org/", "", value)
    attr(x, "dataset_bibentry") <- ds_bibentry
    invisible(x)
  }
}
#' @title Set the Primary Language of a Dataset
#'
#' @description
#' Assign the primary language of a semantically rich dataset object using an
#' ISO 639 language code or full language name. This sets the `language`
#' attribute in the dataset's metadata.
#'
#' @details
#' This function supports recognition of:
#' - 2-letter codes (ISO 639-1, e.g., `"en"`, `"fr"`)
#' - 3-letter codes from both:
#'   - `Alpha_3_B` (bibliographic, e.g., `"fre"`)
#'   - `Alpha_3_T` (terminologic, e.g., `"fra"`)
#' - Full language names (e.g., `"English"`, `"French"`)
#'
#' For compatibility with open science repositories and modern metadata
#' standards, this function **returns the terminologic code** (`Alpha_3_T`)
#' when available. If `Alpha_3_T` is missing for a language, the legacy
#' bibliographic code (`Alpha_3_B`) is used as a fallback.
#'
#' Full language names (e.g., `"English"`, `"Spanish"`) are matched
#' case-insensitively against the ISO 639-2 Name field. Exact matches are
#' attempted first; if none are found, a prefix match is used. For example:
#' - `"English"` returns `"eng"`
#' - `"English, Old"` returns `"ang"`
#'
#' This means that:
#' - Both `"fra"` (terminologic) and `"fre"` (bibliographic) will be accepted
#'   as valid input for French
#' - The resulting value stored and returned will be `"fra"`
#'
#' This behaviour aligns with:
#' - [DataCite Metadata Schema 4.4](https://support.datacite.org/docs/datacite-metadata-schema-v44-recommended-and-optional-properties#9-language)
#' - [schema.org](https://schema.org/inLanguage)
#' - Common repository practices (Zenodo, OSF, Figshare)
#'
#' If `value` is `NULL`, the language is marked as `":unas"` (unspecified).
#'
#' In some cases<U+2014>especially for historical or moribund languages<U+2014>multiple
#' similar names may exist. In such cases, it is safer to use a specific
#' language code (e.g., `"ang"` instead of `"English, Old"` and `"enm"`
#'  for `"English, Middle (1100-1500)"`). You can also
#' refer directly to the definitions in [`ISOcodes::ISO_639_2`]
#' for clarity.
#'
#' @param x A dataset object created by [dataset_df()] or [as_dataset_df()].
#' @param value A 2-letter or 3-letter language code (ISO 639-1 or ISO 639-2),
#'   or a full language name (case-insensitive).
#' @param iso_639_code A character string indicating the desired return format:
#'   either `"639-3"` (default; terminologic) or `"639-1"` (2-letter code).
#'
#' @return The dataset with an updated `language` attribute, typically an ISO
#' 639-2/T code (`Alpha_3_T`) such as `"fra"`, `"eng"`, `"spa"`, etc.
#'
#' @examples
#' df <- dataset_df(data.frame(x = 1:3))
#'
#' language(df) <- "English" # Returns "eng"
#' language(df) <- "fre" # Legacy code; returns "fra"
#' language(df) <- "fra" # Returns "fra"
#' language(df, iso_639_code = "639-1") <- "fra" # Returns "fr"
#'
#' language(df) <- NULL # Sets ":unas"
#'
#' @family bibliographic helper functions
#' @export

language <- function(x) {
  assert_that(is.dataset_df(x),
    msg = "language(x): x must be a dataset object created with dataset() or as_dataset_df()."
  )

  ds_bibentry <- get_bibentry(x)
  as.character(ds_bibentry$language)
}


#' @rdname language
#' @export
`language<-` <- function(x, iso_639_code = "639-3", value) {
  assert_that(
    is.dataset_df(x),
    msg = "language(x)<- value: x must be a dataset object created with dataset() or as_dataset_df()."
  )

  ds_bibentry <- get_bibentry(x)

  # Handle NULL input by assigning placeholder
  if (is.null(value)) {
    ds_bibentry$language <- ":unas"
    attr(x, "dataset_bibentry") <- ds_bibentry
    return(x)
  }

  # Load and normalize ISO language data
  ISO_639 <- ISOcodes::ISO_639_2
  ISO_639 <- as.data.frame(
    lapply(ISO_639, as.character),
    stringsAsFactors = FALSE
  )

  value <- tolower(value)
  lang_entry <- data.frame()

  # Try matching by Alpha_2 (2-letter code)
  if (nchar(value) == 2) {
    lang_entry <- ISO_639[which(tolower(ISO_639$Alpha_2) == value), ]
  }

  # Try matching by Alpha_3_B or Alpha_3_T (3-letter code)
  if (nrow(lang_entry) == 0 && nchar(value) == 3) {
    lang_entry <- ISO_639[
      tolower(ISO_639$Alpha_3_B) == value |
        tolower(ISO_639$Alpha_3_T) == value,
    ]
  }

  # Try matching by full language name
  if (nrow(lang_entry) == 0) {
    lang_entry <- ISO_639[which(tolower(ISO_639$Name) == value), ]
  }

  # If Still not found, fail gracefully
  if (nrow(lang_entry) == 0) {
    stop(paste0(
      "Language='", value,
      "' is not a valid ISO 639 language code."
    ))
  }

  # Assign value according to iso_639_code preference
  if (iso_639_code == "639-1") {
    ds_bibentry$language <- as.character(lang_entry$Alpha_2[1])
  } else {
    # Prefer terminologic code if present and non-empty
    lang3t <- as.character(lang_entry$Alpha_3_T[1])
    lang3b <- as.character(lang_entry$Alpha_3_B[1])

    ds_bibentry$language <- if (!is.na(lang3t) && lang3t != "") {
      lang3t
    } else {
      lang3b
    }
  }

  attr(x, "dataset_bibentry") <- ds_bibentry
  invisible(x)
}

#' @rdname language
#' @export
`language<-` <- function(x, iso_639_code = "639-3", value) {
  assert_that(
    is.dataset_df(x),
    msg = "language(x)<- value: x must be a dataset object created with dataset() or as_dataset_df()."
  )

  ds_bibentry <- get_bibentry(x)

  # Handle NULL input by assigning placeholder
  if (is.null(value)) {
    ds_bibentry$language <- ":unas"
    attr(x, "dataset_bibentry") <- ds_bibentry
    return(x)
  }

  # Load and normalize ISO language data
  ISO_639 <- ISOcodes::ISO_639_2
  ISO_639 <- as.data.frame(
    lapply(ISO_639, as.character),
    stringsAsFactors = FALSE
  )

  value <- tolower(value)
  lang_entry <- data.frame()

  # Try matching by Alpha_2 (2-letter code)
  if (nchar(value) == 2) {
    matches <- which(tolower(ISO_639$Alpha_2) == value)
    if (length(matches) > 0) {
      lang_entry <- ISO_639[matches, ]
    }
  }

  # Try matching by Alpha_3_B or Alpha_3_T (3-letter code)
  if (nrow(lang_entry) == 0 && nchar(value) == 3) {
    matches <- which(
      tolower(ISO_639$Alpha_3_B) == value |
        tolower(ISO_639$Alpha_3_T) == value
    )
    if (length(matches) > 0) {
      lang_entry <- ISO_639[matches, ]
    }
  }

  # Try matching by full language name
  if (nrow(lang_entry) == 0) {
    matches <- which(value == tolower(ISO_639$Name))
    if (length(matches) == 0) {
      matches <- which(grepl(paste0("^", value), tolower(ISO_639$Name)))
    }
    lang_entry <- ISO_639[matches, ]
  }

  # If still not found, fail gracefully
  if (nrow(lang_entry) == 0) {
    stop(
      paste0(
        "Language='", value,
        "' is not a valid ISO 639 language code or name."
      )
    )
  }

  # Assign value according to iso_639_code preference
  if (iso_639_code == "639-1") {
    ds_bibentry$language <- as.character(lang_entry$Alpha_2[1])
  } else {
    # Prefer terminologic code if present and non-empty
    lang3t <- as.character(lang_entry$Alpha_3_T[1])
    lang3b <- as.character(lang_entry$Alpha_3_B[1])

    ds_bibentry$language <- if (!is.na(lang3t) && lang3t != "") {
      lang3t
    } else {
      lang3b
    }
  }

  attr(x, "dataset_bibentry") <- ds_bibentry
  invisible(x)
}
#' Create N-Triples
#'
#' Create RDF triple statements to annotate your dataset with standard,
#' interoperable metadata.
#'
#' N-Triples is a line-based serialization format for RDF. It is easy to parse
#' and widely supported. For details, see the
#' [W3C RDF 1.2 N-Triples specification](https://www.w3.org/TR/rdf12-n-triples/).
#'
#' @param triples A character vector of concatenated N-Triples, created with
#'   [`n_triple()`].
#'
#' @return A character vector of unique N-Triple strings.
#'
#' @examples
#' triple_1 <- n_triple(
#'   "http://example.org/show/218",
#'   "http://www.w3.org/2000/01/rdf-schema#label",
#'   "That Seventies Show"
#' )
#'
#' triple_2 <- n_triple(
#'   "http://example.org/show/218",
#'   "http://example.org/show/localName",
#'   '"Cette Série des Années Septante"@fr-be'
#' )
#'
#' n_triples(c(triple_1, triple_2, triple_1))
#'
#' @export


n_triples <- function(triples) {
  unique(triples)
}

#' @title Create an N-Triple
#' @description Create a single N-Triple triple.
#' @details N-Triples is an easy to parse line-based subset of Turtle to serialize
#' RDF. An N-Triple triple is a sequence of RDF terms representing the subject,
#'  predicate and object of an RDF Triple. Use [n_triples()] to serialize
#'  multiple statements.
#' @source [RDF 1.1 N-Triples](https://www.w3.org/TR/n-triples/)
#' @param s The subject of a triplet.
#' @param p The predicate of a triplet.
#' @param o The object of a triplet.
#' @return A character vector containing one N-Triple string.
#' @examples
#' s <- "http://example.org/show/218"
#' p <- "http://www.w3.org/2000/01/rdf-schema#label"
#' o <- "That Seventies Show"
#' n_triple(s, p, o)
#' @export
n_triple <- function(s, p, o) {
  if (length(o) != 1) {
    stop("n_triple(): object 'o' must be a scalar (length = 1), got: ", length(o))
  }

  s <- create_iri(s)
  p <- create_iri(p)

  # Don't convert `o` if it's already quoted with ^^<...>
  if (grepl('^".+"\\^\\^<.+>$', o) || grepl("^<.+>$", o)) {
    # o is already a well-formed literal or URI
  } else {
    o <- create_iri(o)
  }

  sprintf("%s %s %s .", s, p, o)
}


#' @keywords internal
create_iri <- function(x) {
  if (length(x) != 1) {
    stop("create_iri(): input must be a scalar value (length = 1).")
  }

  if (any(c("list", "data.frame", "tbl", "data.table") %in% class(x))) {
    stop("Error: create_iri(x) must be a scalar URI, string, integer, double, Date, dateTime, or person.")
  }

  double_string <- "^^<http://www.w3.org/2001/XMLSchema#double>"
  integer_string <- "^^<http://www.w3.org/2001/XMLSchema#integer>"
  character_string <- "^^<http://www.w3.org/2001/XMLSchema#string>"
  date_string <- "^^<http://www.w3.org/2001/XMLSchema#date>"
  datetime_string <- "^^<http://www.w3.org/2001/XMLSchema#dateTime>"

  if (inherits(x, "person")) {
    if ("isni" %in% tolower(names(x$comment))) {
      x <- paste0("https://isni.org/isni/", x$comment[which(tolower(names(x$comment)) == "isni")])
    } else if ("orcid" %in% tolower(names(x$comment))) {
      x <- paste0("https://orcid.org/", x$comment[which(tolower(names(x$comment)) == "orcid")])
    } else if ("viaf" %in% tolower(names(x$comment))) {
      x <- paste0("https://viaf.org/viaf/", x$comment[which(tolower(names(x$comment)) == "viaf")])
    } else if ("wikidata" %in% tolower(names(x$comment))) {
      qid <- x$comment[which(tolower(names(x$comment)) == "wikidata")]
      qid <- gsub("https://www.wikidata.org/wiki/", "", qid)
      x <- paste0("https://www.wikidata.org/wiki/", qid)
    } else {
      name_parts <- c(x$given, x$family)
      role_part <- if (!is.null(x$role)) paste0("[", x$role, "]") else ""
      x <- paste(trimws(paste(name_parts, collapse = " ")), role_part)
    }
  }

  if (is.integer(x)) {
    sprintf('"%s"%s', as.character(x), integer_string)
  } else if (inherits(x, "POSIXct")) {
    xsd_convert(x)
  } else if (is.character(x) && substr(x, 1, 5) %in% c("http:", "https")) {
    sprintf("<%s>", as.character(x))
  } else if (grepl("^_\\:", x)) {
    x # return blank node unquoted
  } else if (grepl("@", x)) {
    sprintf('"%s"', x)
  } else if (inherits(x, "Date")) {
    sprintf('"%s"%s', as.character(x), date_string)
  } else if (is.numeric(x)) {
    sprintf('"%s"%s', as.character(x), double_string)
  } else if (x == "a") {
    "<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>"
  } else if (is.character(x)) {
    x <- gsub("DCMITYPE\\:", "http://purl.org/dc/dcmitype/", x)
    sprintf('"%s"%s', as.character(x), character_string)
  }
}


#' @keywords internal
prov_author <- function(author_person) {
  # Handle multiple authors
  if (length(author_person) > 1) {
    return(unlist(lapply(author_person, prov_author), use.names = FALSE))
  }

  person_iri <- NULL # <-- initialize early
  print_name <- ""

  if (inherits(author_person, "person")) {
    print_name <- "_:"
    if (!is.null(author_person$family)) print_name <- paste0(print_name, tolower(author_person$family))
    if (!is.null(author_person$given)) print_name <- paste0(print_name, tolower(author_person$given))
    person_iri <- get_person_iri(author_person)
  } else if (is.character(attr(author_person, "person"))) {
    print_name <- paste0(attr(author_person, "person"), ": ")
  }

  if (!is.null(person_iri)) {
    n_triple(person_iri, "a", "http://www.w3.org/ns/prov#Agent")
  } else {
    n_triple(print_name, "a", "http://www.w3.org/ns/prov#Agent")
  }
}

#' @keywords internal
get_person_iri <- function(p) {
  assertthat::assert_that(inherits(p, "person"),
    msg = "Error: get_person_iri(p): p is not a utils::person object."
  )

  if (!is.null(p$comment)) {
    comment_names <- tolower(names(p$comment))
    comment_values <- p$comment

    if ("orcid" %in% comment_names) {
      id <- comment_values[which(comment_names == "orcid")[1]]
      if (!grepl("^https://orcid.org/", id)) id <- paste0("https://orcid.org/", id)
      return(id)
    } else if ("isni" %in% comment_names) {
      id <- comment_values[which(comment_names == "isni")[1]]
      if (!grepl("^https://isni.org/isni/", id)) id <- paste0("https://isni.org/isni/", id)
      return(id)
    } else if ("viaf" %in% comment_names) {
      id <- comment_values[which(comment_names == "viaf")[1]]
      if (!grepl("^https://viaf.org/viaf/", id)) id <- paste0("https://viaf.org/viaf/", id)
      return(id)
    } else if ("wikidata" %in% comment_names) {
      qid <- comment_values[which(comment_names == "wikidata")[1]]
      qid <- sub("^https://www.wikidata.org/wiki/", "", qid) # strip if already full
      return(paste0("https://www.wikidata.org/wiki/", qid))
    }
  }

  NULL
}


#' @keywords internal
expand_triples <- function(dataset_id, predicate_uri, values) {
  if (is.null(values)) {
    return(character(0))
  }

  # Normalize: wrap scalar in list
  if (!is.list(values)) values <- as.list(values)

  # Filter invalid/placeholder values
  values <- Filter(function(x) {
    !is.null(x) &&
      length(x) == 1 &&
      !is.na(x) &&
      !(as.character(x) %in% c("", ":unas", ":tba"))
  }, values)

  if (length(values) == 0) {
    return(character(0))
  }

  vapply(values, function(val) {
    if (inherits(val, "person")) {
      val <- format(val)
    }
    n_triple(dataset_id, predicate_uri, val)
  }, character(1))
}
#' @keywords internal

normalize_roles <- function(people, default_role = "ctb") {
  lapply(people, function(p) {
    if (!inherits(p, "person")) {
      return(p)
    }
    if (is.null(p$role) || !any(nzchar(p$role))) {
      p$role <- default_role
    }
    p
  })
}
#' @title Get or update provenance information
#'
#' @description
#' Retrieve or append provenance statements (in N‑Triples form) stored on a
#' [`dataset_df()`] object.
#'
#' @details
#' Provenance is stored in the `"prov"` attribute as N‑Triples text. Use
#' [n_triple()] or [n_triples()] to construct valid statements that follow
#' PROV‑O (e.g., `prov:wasGeneratedBy`, `prov:wasInformedBy`).
#'
#' @param x A dataset created with [dataset_df()].
#' @param value Character vector of N‑Triples created by [n_triple()] or
#'   [n_triples()] to append to existing provenance.
#'
#' @return
#' * `provenance(x)` returns the contents of the `"prov"` attribute (character
#'   vector of N‑Triples), or `NULL` if none is set.
#' * `provenance(x) <- value` appends `value` to the `"prov"` attribute and
#'   returns the modified dataset invisibly.
#'
#' @examples
#' provenance(orange_df)
#'
#' # Add a provenance statement:
#' provenance(orange_df) <- n_triple(
#'   "https://doi.org/10.5281/zenodo.10396807",
#'   "http://www.w3.org/ns/prov#wasInformedBy",
#'   "http://example.com/source#1"
#' )
#'
#' @importFrom utils citation
#' @export
provenance <- function(x) {
  if (!is.dataset_df(x)) {
    stop("provenance(x): x must be a dataset_df object with standardised provenance metadata.")
  }
  attr(x, "prov")
}

#' @rdname provenance
#' @export
`provenance<-` <- function(x, value) {
  if (!is.dataset_df(x)) {
    stop("provenance(x)<- : x must be a dataset object created with dataset_df() or as_dataset_df().")
  }

  old_provenance <- provenance(x)
  new_provenance <- old_provenance

  attr(x, "prov") <- c(new_provenance, value)
  invisible(x)
}

#' @title Build default provenance bundle
#' @description
#' Construct a small PROV bundle (as N‑Triples) describing the dataset, the
#' software agent, and an optional creation time.
#'
#' @details
#' This helper is used internally to seed provenance metadata. It emits a set of
#' PROV statements including an `Entity` for the dataset, an `Activity` for
#' creation, and `SoftwareAgent` entries for the package citation.
#'
#' @param dataset_id Base IRI for the dataset (used as the `Entity` subject).
#' @param author Optional creator/author agent.
#' @param dtm Optional data team/maintainer agent.
#' @param generated_at_time Optional POSIXct time; defaults to [Sys.time()].
#'
#' @return A character vector of N‑Triples suitable for the `"prov"` attribute.
#'
#' @keywords internal
#' @importFrom utils citation
default_provenance <- function(dataset_id = "http://example.com/dataset#",
                               author = NULL,
                               dtm = NULL,
                               generated_at_time = NULL) {
  cite_dataset <- utils::citation("dataset")

  # See prov_author in n_triple.R
  agent_triples <- c()
  if (!is.null(author)) agent_triples <- c(agent_triples, prov_author(author))
  if (!is.null(dtm)) agent_triples <- c(agent_triples, prov_author(dtm))

  if (is.null(generated_at_time)) {
    generated_at_time <- Sys.time()
  }

  bundle_id <- gsub("#", "_prov.nt", dataset_id)

  prov <- n_triples(
    c(
      n_triple(bundle_id, "a", "http://www.w3.org/ns/prov#Bundle"),
      n_triple(dataset_id, "a", "http://www.w3.org/ns/prov#Entity"),
      n_triple(dataset_id, "a", "http://purl.org/linked-data/cube#DataSet"),
      agent_triples,
      n_triple("https://doi.org/10.32614/CRAN.package.dataset", "a", "http://www.w3.org/ns/prov#SoftwareAgent"),
      n_triple("http://example.com/creation", "a", "http://www.w3.org/ns/prov#Activity"),
      n_triple("http://example.com/creation", "http://www.w3.org/ns/prov#generatedAtTime", xsd_convert(generated_at_time)),
      n_triple(paste0("https://doi.org/", cite_dataset[[2]]$doi), "a", "http://www.w3.org/ns/prov#SoftwareAgent")
    )
  )

  prov
}
#' @title Get or Set the Publication Year of a Dataset Object
#'
#' @description
#' Access or assign the optional `publication_year` attribute to a semantically
#' rich dataset object.
#'
#' @details
#' The `publication_year` represents the year when the dataset was or will be
#' made publicly available, in `YYYY` format. For additional context, see
#' [DataCite: Publication Year-Additional Guidance](https://support.datacite.org/docs/datacite-metadata-schema-v44-mandatory-properties#publicationyearadditional-guidance).
#'
#' @param x A dataset object created by [dataset_df()] or
#'   `dataset::as_dataset_df()`.
#' @param value A character string specifying the publication year.
#' @param overwrite Logical. If `TRUE` (default), the existing
#'   `publication_year` attribute is replaced with `value`. If `FALSE`, the
#'   function returns a message and does not overwrite the existing value.
#'
#' @return The `publication_year` attribute as a character string.
#'
#' @examples
#' publication_year(orange_df)
#' publication_year(orange_df) <- "1998"
#'
#' @family bibliographic helper functions
#' @export

publication_year <- function(x) {
  assert_that(is.dataset_df(x),
    msg = "publication_year(x): x must be a dataset object created with dataset() or as_dataset()."
  )

  ds_bibentry <- get_bibentry(x)
  as.character(ds_bibentry$date)
}

#' @rdname publication_year
#' @export
`publication_year<-` <- function(x, overwrite = TRUE, value) {
  assert_that(is.dataset_df(x),
    msg = "publication_year(x) <- value: x must be a dataset object created with dataset_df() or as_dataset_df()."
  )

  ds_bibentry <- get_bibentry(x)
  publication_year <- ds_bibentry$date

  if (is.null(value)) {
    value <- ":unas"
  }

  if (overwrite) {
    ds_bibentry$date <- as.character(value)
    attr(x, "dataset_bibentry") <- ds_bibentry
  } else {
    warning("The dataset has already an publication_year: ", ds_bibentry$date, ".")
  }
  invisible(x)
}
#' Get or Set the Publisher of a Dataset Object
#'
#' Adds or retrieves the optional `"publisher"` attribute for a dataset object.
#' This property aligns with `dct:publisher` (Dublin Core) and `publisher`
#' (DataCite).
#'
#' @description
#' The publisher is the entity responsible for holding, archiving, releasing,
#' or distributing the resource. It is typically included in dataset citation
#' metadata.
#'
#' For software, this might refer to a code repository (e.g., GitHub). If both
#' a hosting platform and a producing institution are involved, use the
#' publisher for the institution and [creator()] with
#' `contributorType = "hostingInstitution"` for the platform.
#'
#' @param x A dataset object created with [dataset_df()] or
#'   [as_dataset_df()].
#' @param overwrite Logical. Should existing publisher metadata be overwritten?
#'   Defaults to `FALSE`. If `FALSE` and the field exists, a warning is issued.
#' @param value A character string specifying the publisher.
#'
#' @return
#' A character string of length one containing the `"publisher"` attribute.
#' When assigning, the updated object `x` is returned invisibly.
#'
#' @examples
#' publisher(orange_df) <- "Wiley"
#' publisher(orange_df)
#'
#' @family bibliographic helper functions
#' @importFrom assertthat assert_that
#' @export

publisher <- function(x) {
  assert_that(is.dataset_df(x),
    msg = "publisher(x): x must be a dataset object created with dataset() or as_dataset()."
  )

  DataBibentry <- get_bibentry(x)
  as.character(DataBibentry$publisher)
}

#' @rdname publisher
#' @export
`publisher<-` <- function(x, overwrite = TRUE, value) {
  if (!is.dataset_df(x)) {
    stop("publisher(x): x must be a dataset object created with dataset() or as_dataset().")
  }

  DataBibentry <- invisible(get_bibentry(x))

  if (is.null(value)) {
    DataBibentry$publisher <- ":tba"
    attr(x, "dataset_bibentry") <- DataBibentry
    return(x)
  }

  if (length(value) > 1) {
    stop("publisher(x) <- value: value must be of length 1.")
  }

  is_tba <- DataBibentry$publisher == ":tba"

  if (is.null(DataBibentry$publisher)) {
    DataBibentry$publisher <- value
  } else if (is_tba) {
    DataBibentry$publisher <- value
  } else if (overwrite) {
    DataBibentry$publisher <- value
  } else {
    message(
      "The dataset has already an Publisher: ",
      DataBibentry$publisher
    )
  }

  attr(x, "dataset_bibentry") <- DataBibentry
  invisible(x)
}
#' @title Add or retrieve related items (DataCite/Dublin Core)
#'
#' @description Manage related resources for a dataset using a unified accessor.
#' - For **DataCite 4.x**, this maps to `relatedIdentifier` (+ type & relation).
#' - For **Dublin Core**, this maps to `dct:relation` (string).
#'
#' @details To remain compatible with [utils::bibentry()], the bibentry stores
#' only the
#' **string identifier** (e.g., DOI/URL). The full structured object created by
#' [related_create()] is preserved in the `"relation"` attribute.
#'
#' A `"related"` object is a small S3 list with the following elements:
#' - `relatedIdentifier`: the related resource identifier (DOI, URL, etc.)
#' - `relationType`: the DataCite relation type (e.g., `"IsPartOf"`, `"References"`)
#' - `relatedIdentifierType`: the type of identifier (`"DOI"`, `"URL"`, etc.)
#' - `resourceTypeGeneral`: optional, the general type of the related resource (e.g., `"Text"`, `"Dataset"`)
#'
#' @param x A dataset object created with [dataset_df()] or [as_dataset_df()].
#' @param value A `related` object from [related_create()] or a character.
#'   Vectors of characters are also supported and will be converted to a list of
#'   `"related"` objects.
#' @param relatedIdentifier A string with the identifier of the related
#'   resource.
#' @param relationType A string naming the relation type (per DataCite
#'   vocabulary).
#' @param relatedIdentifierType A string naming the identifier type (`"DOI"`,
#'   `"URL"`, etc.).
#' @param resourceTypeGeneral Optional: a string naming the general type of the
#'   related resource.
#'
#' @return
#' * `relation(x)` returns:
#'   - a single structured `"related"` object (from [related_create()]) if only
#' one relation is present,
#'   - a list of `"related"` objects if multiple relations are present,
#'   - otherwise it falls back to the bibentry field (`relatedidentifier` for
#' DataCite or `relation` for Dublin Core).
#' * `relation(x) <- value` sets the `"relation"` attribute (structured object
#' or list of objects) and the bibentry string fields (`relatedidentifier` and
#' `relation`), and returns the dataset invisibly.
#' * `related_create()` constructs a structured `"related"` object.
#' * `is.related(x)` returns `TRUE` if `x` inherits from class `"related"`.
#'
#' @examples
#' df <- dataset_df(data.frame(x = 1))
#' relation(df) <- related_create(
#'   relatedIdentifier = "10.1234/example",
#'   relationType = "IsPartOf",
#'   relatedIdentifierType = "DOI"
#' )
#' relation(df) # structured object
#' get_bibentry(df)$relation # "10.1234/example"
#' get_bibentry(df)$relatedidentifier # "10.1234/example"
#'
#' # Character input is normalized to a DOI/URL with default types
#' relation(df) <- "https://doi.org/10.5678/xyz"
#' relation(df) # structured object (relationType/Type filled with defaults)
#'
#' # Create related object directly
#' rel <- related_create("https://doi.org/10.5678/xyz", "References", "DOI")
#' is.related(rel) # TRUE
#'
#' @family bibliographic helper functions
#' @export
relation <- function(x) {
  assertthat::assert_that(
    is.dataset_df(x),
    msg = "relation(x): x must be a dataset_df object."
  )

  rel_attr <- attr(x, "relation", exact = TRUE)
  if (!is.null(rel_attr)) {
    if (is.related(rel_attr)) {
      return(rel_attr)
    }
    if (is.list(rel_attr) && all(vapply(rel_attr, is.related, logical(1)))) {
      return(if (length(rel_attr) == 1) rel_attr[[1]] else rel_attr)
    }
    return(rel_attr)
  }

  be <- get_bibentry(x)
  if (!is.null(be$relatedidentifier)) {
    return(be$relatedidentifier)
  }
  if (!is.null(be$relation)) {
    return(be$relation)
  }

  message("No related item is recorded.")
  NULL
}

#' @rdname relation
#' @export
`relation<-` <- function(x, value) {
  assertthat::assert_that(
    is.dataset_df(x),
    msg = "relation<-(x, value): x must be a dataset_df object created with dataset_df() or as_dataset_df()."
  )

  be <- get_bibentry(x)

  # --- normalize input ---
  if (is.null(value)) {
    value <- list(related_create(":unas", "IsPartOf", "URL"))
  } else if (is.character(value)) {
    # allow vector of strings too
    value <- lapply(value, function(v) {
      related_create(
        relatedIdentifier = v,
        relationType = "IsPartOf",
        relatedIdentifierType = if (grepl("^https?://", v)) "URL" else "DOI"
      )
    })
  } else if (is.related(value)) {
    value <- list(value) # wrap single related in a list
  } else if (is.list(value) && all(vapply(value, is.related, logical(1)))) {
    # already a list of related objects → nothing to do
  } else {
    stop("relation(x, value)<- : value must be created with `related_create()` or be a character string (or list thereof).")
  }

  # --- store in dataset_bibentry ---
  # keep only the identifiers (vector of strings)
  be$relatedidentifier <- vapply(value, function(v) v$relatedIdentifier, character(1))
  be$relation <- be$relatedidentifier
  attr(be, "relation") <- value # structured list of related items

  attr(x, "dataset_bibentry") <- be
  attr(x, "relation") <- value

  invisible(x)
}

#' @rdname relation
#' @export
related_create <- function(relatedIdentifier,
                           relationType,
                           relatedIdentifierType,
                           resourceTypeGeneral = NULL) {
  rel <- list(
    relatedIdentifier = as.character(relatedIdentifier),
    relationType = as.character(relationType),
    relatedIdentifierType = as.character(relatedIdentifierType),
    resourceTypeGeneral = if (is.null(resourceTypeGeneral)) NULL else as.character(resourceTypeGeneral)
  )
  class(rel) <- c("related", "list")
  rel
}

#' @rdname relation
#' @export
is.related <- function(x) inherits(x, "related")

#' @rdname relation
#' @export
related_item <- relation

#' @rdname relation
#' @export
`related_item<-` <- `relation<-`
#' Get or Set the Rights of a Dataset Object
#'
#' Adds or retrieves the optional `"rights"` attribute of a dataset object.
#' This field contains information about intellectual property or usage rights.
#'
#' @details
#' The `"rights"` field corresponds to
#' [dct:rights](https://www.dublincore.org/specifications/dublin-core/dcmi-terms/elements11/rights/)
#' from Dublin Core, and to `rights` in [DataCite](https://schema.datacite.org/).
#'
#' Rights information typically includes statements about legal ownership,
#' licensing, or usage conditions. It helps ensure that users understand how
#' a dataset may be reused, cited, or shared.
#'
#' @param x A semantically rich data frame created with [dataset_df()] or
#'   [as_dataset_df()].
#' @param value A character string specifying the rights (e.g., `"CC-BY-4.0"`).
#' @param overwrite Logical. Should the existing value be replaced? If `FALSE`
#'   and a value already exists, the function emits a message instead of
#'   overwriting. Defaults to `FALSE`.
#'
#' @return
#' The `"rights"` attribute of the dataset as a character string (length 1).
#' When assigning, the updated object `x` is returned invisibly.
#'
#' @examples
#' rights(orange_df) <- "CC-BY-SA"
#' rights(orange_df)
#'
#' @family bibliographic helper functions
#' @export

rights <- function(x) {
  assertthat::assert_that(is.dataset_df(x),
    msg = "rights(x): x must be a dataset object created with dataset_df() or as_dataset_df()."
  )

  DataBibentry <- get_bibentry(x)
  as.character(DataBibentry$rights)
}

#' @rdname rights
#' @export
`rights<-` <- function(x, overwrite = FALSE, value) {
  assertthat::assert_that(is.dataset_df(x),
    msg = "rights(x): x must be a dataset object created with dataset_f() or as_dataset_df()."
  )

  assertthat::assert_that(is.null(value) | length(value) == 1,
    msg = "rights(x): x must have length=1 (or set to NULL)."
  )

  DataBibentry <- invisible(get_bibentry(x))

  if (is.null(value)) {
    DataBibentry$rights <- ":unas"
    attr(x, "dataset_bibentry") <- DataBibentry
    return(invisible(x))
  }

  if (length(value) > 1) {
    stop("rights(x) <- value: value must be of length 1.")
  }

  is_unas <- DataBibentry$rights == ":unas"

  if (is.null(DataBibentry$rights)) {
    DataBibentry$rights <- value
  } else if (is_unas) {
    DataBibentry$rights <- value
  } else if (overwrite) {
    DataBibentry$rights <- value
  } else {
    message("The dataset has already a rights field: ", DataBibentry$rights)
  }

  attr(x, "dataset_bibentry") <- DataBibentry
  invisible(x)
}
#' @title Create, add, or retrieve a subject
#'
#' @description
#' Manage the subject metadata of a dataset. The subject can be stored as a
#' simple character term or as a structured object with subproperties created by
#' [subject_create()].
#'
#' @details
#' The subject property records what the dataset is about.
#' The [DataCite subject property](https://schema.datacite.org/meta/kernel-4/)
#' allows multiple subproperties, but these cannot be stored directly in a
#' standard [`utils::bibentry`] object.
#' Therefore:
#'
#' * If you set a character string as the subject, it is stored in both the
#'   bibentry and the `"subject"` attribute.
#' * If you set a structured subject (via [subject_create()]), the `$term` value
#'   is stored in the bibentry, and the full object is stored in the `"subject"`
#'   attribute of the [`dataset_df`] object.
#'
#' @param x A dataset object created with [dataset_df()] or [as_dataset_df()].
#' @param term A subject term, for example `"Data sets"`.
#' @param schemeURI URI of the subject identifier scheme, for example
#'   `"http://id.loc.gov/authorities/subjects"`.
#' @param valueURI URI of the subject term, for example
#'   `"https://id.loc.gov/authorities/subjects/sh2018002256"`.
#' @param prefix Abbreviated prefix for a scheme URI, for example `"lcch:"`.
#'   Widely used namespaces (schemes) have conventional abbreviations.
#' @param subjectScheme Name of the subject scheme, classification code, or
#'   authority if one is used. This acts as a namespace.
#' @param classificationCode Classification code for schemes that do not have
#'   `valueURI` entries for each subject term (e.g., ANZSRC).
#' @param value A subject object created by [subject_create()] or a character
#'   string. Used by `subject<-` to replace the subject.
#'
#' @return
#' * `subject(x)` returns:
#'   - a single `"subject"` object if only one is present,
#'   - a list of `"subject"` objects if multiple are present,
#'   - otherwise falls back to the plain string from the bibentry.
#' * `subject(x) <- value` accepts a character vector, a `"subject"` object, or
#'   a list of `"subject"` objects, and updates both the bibentry slot and the
#'   `"subject"` attribute. Returns the dataset invisibly.
#' * `subject_create()` returns a structured `"subject"` object — or a list of
#'   them if multiple terms are provided.
#' * `is.subject(x)` returns `TRUE` if `x` inherits from class `"subject"`.
#'
#' @examples
#' # Set a structured subject
#' subject(orange_df) <- subject_create(
#'   term = "Oranges",
#'   schemeURI = "http://id.loc.gov/authorities/subjects",
#'   valueURI = "http://id.loc.gov/authorities/subjects/sh85095257",
#'   subjectScheme = "LCCH",
#'   prefix = "lcch:"
#' )
#'
#' # Retrieve subject with subproperties
#' subject(orange_df)
#'
#' @family bibliographic helper functions
#' @importFrom assertthat assert_that
#' @export
#' @export
subject <- function(x) {
  assertthat::assert_that(
    is.dataset_df(x),
    msg = "subject(x): x must be a dataset_df object created with dataset_df() or as_dataset_df()."
  )

  subj_attr <- attr(x, "subject", exact = TRUE)
  if (!is.null(subj_attr)) {
    if (is.subject(subj_attr)) {
      return(subj_attr)
    }
    if (is.list(subj_attr) && all(vapply(subj_attr, is.subject, logical(1)))) {
      return(if (length(subj_attr) == 1) subj_attr[[1]] else subj_attr)
    }
    return(subj_attr)
  }

  subj_bib <- get_bibentry(x)$subject
  if (!is.null(subj_bib)) {
    return(subj_bib)
  }

  message("No subject is recorded.")
  NULL
}



#' @rdname subject
#' @export
subject_create <- function(term,
                           schemeURI = NULL,
                           valueURI = NULL,
                           prefix = NULL,
                           subjectScheme = NULL,
                           classificationCode = NULL) {
  if (is.null(term)) term <- ":tba"

  if (length(term) > 1) {
    dataset_subject <- lapply(seq_along(term), function(i) {
      new_Subject(
        term[i],
        subjectScheme = subjectScheme[i],
        schemeURI = schemeURI[i],
        valueURI = if (!is.null(valueURI)) valueURI[i] else NULL,
        classificationCode = if (!is.null(classificationCode)) classificationCode[i] else NULL,
        prefix = prefix[i]
      )
    })
    # don’t force class on the whole list
    return(dataset_subject)
  } else {
    return(new_Subject(
      term = term,
      subjectScheme = subjectScheme,
      schemeURI = schemeURI,
      valueURI = valueURI,
      classificationCode = classificationCode,
      prefix = prefix
    ))
  }
}

#' @inheritParams Subject
#' @keywords internal
new_Subject <- function(term,
                        schemeURI = NULL,
                        valueURI = NULL,
                        prefix = NULL,
                        subjectScheme = NULL,
                        classificationCode = NULL) {
  if (is.null(subjectScheme)) subjectScheme <- ""
  if (is.null(schemeURI)) schemeURI <- ""
  if (is.null(valueURI)) valueURI <- ""
  if (is.null(prefix)) prefix <- ""

  if (!is.null(classificationCode)) {
    dataset_subject <- list(
      term = term,
      subjectScheme = subjectScheme,
      schemeURI = schemeURI,
      classificationCode = classificationCode,
      prefix = prefix
    )
  } else {
    dataset_subject <- list(
      term = term,
      subjectScheme = subjectScheme,
      schemeURI = schemeURI,
      valueURI = valueURI,
      classificationCode = classificationCode,
      prefix = prefix
    )
  }

  class(dataset_subject) <- c("subject", class(dataset_subject))

  dataset_subject
}

#' @rdname subject
#' @export
`subject<-` <- function(x, value) {
  assert_that(
    is.dataset_df(x),
    msg = "subject<-(x, value): x must be a dataset object created with dataset_df() or as_dataset_df()."
  )

  ds_bibentry <- get_bibentry(x)

  # normalize input
  if (is.null(value)) {
    value <- list(new_Subject(term = ":tba"))
  } else if (is.character(value)) {
    value <- lapply(value, new_Subject)
  } else if (is.subject(value)) {
    value <- list(value) # wrap single subject
  } else if (is.list(value) && all(vapply(value, is.subject, logical(1)))) {
    # already a list of subjects, ok
  } else {
    stop("subject(x, value)<- : value must be created with `subject_create()` or be a character string (or list thereof).")
  }

  # flatten terms into bibentry
  ds_bibentry$subject <- vapply(value, function(s) s$term, character(1))
  attr(x, "dataset_bibentry") <- ds_bibentry

  # keep full structured objects
  attr(x, "subject") <- value

  invisible(x)
}

#' @rdname subject
is.subject <- function(x) {
  ifelse(inherits(x, "subject"), TRUE, FALSE)
}

#' @keywords internal
default_subject <- subject_create(
  term = "Data sets",
  subjectScheme = "LCSH",
  schemeURI = "http://id.loc.gov/authorities/subjects",
  valueURI = "http://id.loc.gov/authorities/subjects/sh2018002256",
  prefix = "lcsh:"
)
#' @keywords internal
idcol_find <- function(x, idcol) {
  if (is.null(idcol)) {
    stop("idcol_find: 'idcol' must be specified.")
  }

  # Case: character column name
  if (is.character(idcol)) {
    if (!idcol %in% names(x)) {
      stop(sprintf("idcol_find: column '%s' not found in data frame.", idcol))
    }
    selected <- which(names(x) == idcol)

    # Case: numeric column index
  } else if (is.numeric(idcol)) {
    if (!idcol %in% seq_along(x)) {
      stop(sprintf("idcol_find: column index %s is out of bounds.", idcol))
    }
    selected <- idcol

    # Unsupported type
  } else {
    stop("idcol_find: 'idcol' must be a column name (character) or index (numeric).")
  }

  if (length(selected) != 1) {
    stop("idcol_find: 'idcol' must refer to exactly one column.")
  }

  selected
}
#' @keywords internal
`%||%` <- function(x, y) {
  if (is.null(x)) y else x
}
#' @title Get / set a concept definition for a vector or a dataset
#' @param x a vector
#' @param value a character string or `NULL` to remove the concept definition of
#'   a measure.
#' @param ... Further parameters for inheritance, not in use.
#' @details `get_variable_concepts()` is identical to `var_concept()`.
#' @examples
#' small_country_dataset <- dataset_df(
#'   country_name = defined(c("Andorra", "Lichtenstein"), label = "Country"),
#'   gdp = defined(c(3897, 7365),
#'     label = "Gross Domestic Product",
#'     unit = "million dollars"
#'   )
#' )
#' var_concept(small_country_dataset$country_name) <- "http://data.europa.eu/bna/c_6c2bb82d"
#' var_concept(small_country_dataset$country_name)
#' # To remove a concept definition of variable
#' var_concept(small_country_dataset$country_name) <- NULL
#' @return The (linked) concept of the meaning of the data contained by a
#'   vector constructed with[defined()].
#' @export

var_concept <- function(x, ...) {
  # rlang::check_dots_used()
  UseMethod("var_concept")
}

#' @export
var_concept.default <- function(x, ...) {
  concept <- attr(x, "concept", exact = TRUE)

  # Fallback to deprecated 'definition' attribute
  if (is.null(concept)) {
    legacy <- attr(x, "definition", exact = TRUE)
    if (!is.null(legacy)) {
      warning("Attribute `definition` is deprecated; please rename to `concept`.", call. = FALSE)
      return(legacy)
    }
  }

  concept
}

#' @rdname var_concept
#' @export
`var_concept<-` <- function(x, value) {
  UseMethod("var_concept<-")
}

#' @rdname var_concept
#' @param x A vector to which the concept URI will be assigned.
#' @param value A character string with a concept URI or NULL to remove the concept.
#' @description Assigns a concept URI to a vector created with `defined()`. This
#' method updates the `concept` attribute and validates that the input is a single
#' character string or NULL.
#' @return The modified vector with updated `concept` metadata.
#' @export
#' @examples
#' x <- defined(c(1, 2, 3), label = "Example Variable")
#' var_concept(x) <- "http://example.org/concept/XYZ"
#' var_concept(x)
`var_concept<-.default` <- function(x, value) {
  if ((!is.character(value) && !is.null(value)) || length(value) > 1) {
    stop("`concept` must be a single character string or NULL", call. = FALSE)
  }
  attr(x, "concept") <- value
  x
}

#' @title Get concepts for all variables in a dataset_df
#' @description Returns a named list of concept URIs (or NULLs) for all
#'   variables.
#' @param x A `dataset_df` object.
#' @return A named list of concept URIs for each variable.
#' @examples get_variable_concepts(orange_df)
#' @export
get_variable_concepts <- function(x) {
  if (!is.dataset_df(x)) {
    stop("get_variable_concepts(x): x must be a dataset_df object.", call. = FALSE)
  }

  lapply(x, var_concept)
}
#' Get or Set a Variable Label
#'
#' Adds or retrieves a human-readable label as a metadata attribute for a
#' variable or vector. This label is useful for making variables easier to
#' understand than their programmatic names (e.g., column names).
#'
#' @details
#' This interface builds on [labelled::var_label()] and is compatible with
#' the `defined()` infrastructure for semantic metadata (labels, namespaces,
#' units, and variable identifiers).
#'
#' See [labelled::var_label()] for low-level usage. For a comprehensive
#' guide to working with variable labels and semantic metadata, see:
#' `vignette("defined", package = "dataset")`.
#'
#' @param x A vector or data frame.
#' @param value A character string or `NULL` to remove the label.
#'   When used with `var_labels()` on a data frame, this can also be a named list
#'   or a character vector of the same length as the number of columns in `x`.
#' @param ... Further arguments passed to or used by methods.
#'
#' @return
#' - `var_label(x)` returns the `"label"` attribute of `x` as a character string.
#' - `var_label(x) <- value` sets, removes, or replaces the label attribute of `x`,
#' returning the updated object invisibly.
#'
#' @examples
#' # Retrieve the label attribute
#' var_label(orange_df$circumference)
#'
#' # Set or update the label attribute
#' var_label(orange_df$circumference) <- "circumference (breast height)"
#'
#' @seealso [labelled::var_label()], [var_labels()], [defined()]
#' @family defined metadata methods and functions
#'
#' @name var_label
#' @export
#' @importFrom labelled var_label
#' @importFrom labelled `var_label<-`
NULL

#' @rdname var_label
#' @export
#' @importFrom labelled `var_label<-`
var_label.defined <- function(x, ...) {
  NextMethod()
}
#' @rdname var_label
#'
#' @description
#' `label_attribute()` is a low-level helper that retrieves the `"label"` attribute
#' of an object without any fallback or printing logic. It is primarily used internally.
#'
#' @return
#' A character string if the `"label"` attribute exists, or `NULL` if not present.
#'
#' @export
#' @importFrom labelled label_attribute
label_attribute <- function(x) {
  attr(x, "label", exact = TRUE)
}

#' @rdname var_label
#'
#' @description
#' The `var_label<-` assignment method sets or removes the `"label"` attribute
#' of a vector or data frame column. This allows attaching human-readable
#' descriptions to variables for interpretability and downstream metadata use.
#'
#' @param value A character string to assign as the label, or `NULL` to remove it.
#'
#' @return
#' The modified object `x`, returned invisibly with the updated `"label"` attribute.
#'
#' @export
`var_label<-` <- function(x, value) {
  UseMethod("var_label<-")
}

#' @rdname var_label
#' @export
#' @importFrom labelled `var_label<-`
`var_label<-.haven_labelled_defined` <- function(x, value) {
  attr(x, "label") <- value
  x
}

#' @rdname var_label
#'
#' @param unlist For data frames, return a named vector instead of a list.
#' @param null_action For data frames, controls how to handle columns without a variable label.
#'   Options are:
#'   - `"keep"` (default): keep `NULL` for unlabeled columns
#'   - `"fill"`: use the column name as a fallback
#'   - `"skip"`: exclude columns with no label from the result
#'   - `"na"`: use `NA_character_`
#'   - `"empty"`: use an empty string `""`
#' @param recurse If `TRUE`, applies `var_label()` recursively on packed columns
#'   (as created by [tidyr::pack()]) to retrieve sub-column labels. If `FALSE`,
#'   only the outer (grouped) column label is returned.
#' @examples
#' # Example: Retrieve variable labels from a dataset_df
#' df <- dataset_df(
#'   id = defined(1:3, label = "Observation ID"),
#'   temp = defined(c(22.5, 23.0, 21.8), label = "Temperature (°C)"),
#'   site = defined(c("A", "B", "A"))
#' )
#'
#' # List form (default)
#' var_label(df)
#'
#' # Character vector form
#' var_label(df, unlist = TRUE, null_action = "empty")
#'
#' # Exclude variables without labels
#' var_label(df, null_action = "skip")
#'
#' # Replace missing labels with column names
#' var_label(df, null_action = "fill")
#' @export
var_label.dataset_df <- function(x,
                                 unlist = FALSE,
                                 null_action = c("keep", "fill", "skip", "na", "empty"),
                                 recurse = FALSE,
                                 ...) {
  null_action <- match.arg(null_action)

  result <- lapply(names(x), function(name) {
    col <- x[[name]]

    if (recurse && inherits(col, "data.frame")) {
      return(var_label(col, unlist = unlist, null_action = null_action, recurse = recurse, ...))
    }

    label <- var_label(col)

    if (is.null(label)) {
      label <- switch(null_action,
        keep = NULL,
        fill = name,
        skip = NULL,
        na = NA_character_,
        empty = ""
      )
    }

    label
  })

  names(result) <- names(x)

  if (null_action == "skip") {
    result <- result[!vapply(result, is.null, logical(1))]
  }

  if (unlist) {
    return(unlist(result, use.names = TRUE))
  }

  result
}
#' @title Get or set all variable labels on a dataset
#'
#' @description
#' Retrieve or assign labels for all variables (columns) in a dataset.
#'
#' @details
#' This is the dataset-level equivalent of [var_label()].
#' It works with any `data.frame`-like object, including [dataset_df()], and
#' returns/sets the `"label"` attribute of each column.
#'
#' Labels are useful for storing human-readable descriptions of variables that
#' may have short or cryptic column names.
#'
#' For internal purposes, this function uses the `"var_labels"` dataset
#' attribute and delegates to [var_label()] and
#' [var_label<-()] on individual columns.
#'
#' @param x A `data.frame` or [`dataset_df`] object.
#' @param value
#'   - For setting: a named list or named character vector of labels.
#'     Names must match column names in `x`.
#'     Unnamed elements are ignored.
#'   - For getting: ignored.
#' @param unlist Logical; if `TRUE`, return a named character vector instead
#'   of a list. Defaults to `FALSE`.
#' @param null_action How to handle columns without labels. One of:
#'   - `"keep"` (default): keep `NULL` values for unlabeled columns.
#'   - `"fill"`: use the column name as a fallback label.
#'   - `"skip"`: exclude unlabeled columns from the result.
#'   - `"na"`: use `NA_character_` for unlabeled columns.
#'   - `"empty"`: use an empty string `""` for unlabeled columns.
#'
#' @return
#' * Getter: a named list (or vector if `unlist = TRUE`) of variable labels.
#' * Setter: the modified `x` with updated labels, returned invisibly.
#'
#' @examples
#' df <- dataset_df(
#'   id = defined(1:3, label = "Observation ID"),
#'   temp = defined(c(22.5, 23.0, 21.8), label = "Temperature (°C)"),
#'   site = defined(c("A", "B", "A"))
#' )
#'
#' # Get all variable labels
#' var_labels(df)
#'
#' # Set multiple labels at once
#' var_labels(df) <- list(site = "Site code")
#'
#' # Return as a named vector with empty string for unlabeled vars
#' var_labels(df, unlist = TRUE, null_action = "empty")
#'
#' @seealso [var_label()]
#' @family defined metadata methods and functions
#' @export
var_labels <- function(x,
                       unlist = FALSE,
                       null_action = c("keep", "fill", "skip", "na", "empty")) {
  null_action <- match.arg(null_action)
  stopifnot(is.data.frame(x))

  result <- lapply(names(x), function(name) {
    lbl <- var_label(x[[name]])
    if (is.null(lbl)) {
      lbl <- switch(null_action,
        keep = NULL,
        fill = name,
        skip = NULL,
        na = NA_character_,
        empty = ""
      )
    }
    lbl
  })
  names(result) <- names(x)

  if (null_action == "skip") {
    result <- result[!vapply(result, is.null, logical(1))]
  }
  if (unlist) {
    return(unlist(result, use.names = TRUE))
  }
  result
}

#' @rdname var_labels
#' @export
`var_labels<-` <- function(x, value) {
  stopifnot(is.data.frame(x))
  stopifnot(is.list(value) || is.character(value))

  # Convert character vector to named list if needed
  if (is.character(value) && !is.list(value)) {
    if (is.null(names(value))) {
      stop("Character vector for var_labels() must be named.")
    }
    value <- as.list(value)
  }

  # Only set labels for matching names
  for (nm in intersect(names(x), names(value))) {
    var_label(x[[nm]]) <- value[[nm]]
  }

  # Update dataset-level "var_labels" attribute too
  x <- set_var_labels(x, value)

  invisible(x)
}

#' @keywords internal
set_var_labels <- function(dataset, var_labels) {
  var_label_list <- list()
  var_label_list <- lapply(colnames(dataset), function(i) i)
  names(var_label_list) <- colnames(dataset)

  for (rn in which(names(var_label_list) %in% names(var_labels))) {
    var_label_list[[rn]] <- var_labels[[which(names(var_label_list)[rn] == names(var_labels))]]
  }

  attr(dataset, "var_labels") <- var_label_list

  dataset
}
#' @title Get or Set the Namespace of a Variable
#'
#' @description
#' Retrieve or assign the namespace part of a permanent, global variable
#' identifier, independent of the current R session or instance.
#'
#' @details
#' The `namespace` attribute is useful when working with remote, linked, or
#' open data sources. Variable identifiers in such datasets are often qualified
#' with a common namespace prefix. When combined, the prefix and namespace form
#' a persistent URI or IRI for the variable.
#'
#' Retaining the namespace ensures the identifiers remain valid and resolvable
#' during validation, merging, or future updates of the vector (such as when it
#' is used as a column in a dataset).
#'
#' `get_variable_namespaces()` is an alias for `var_namespace()`.
#' `namespace_attribute()` and `set_namespace_attribute()` are internal helpers.
#'
#' For full usage, see:
#' `vignette("defined", package = "dataset")` <U+2014> demonstrating integration of
#' variable labels, namespaces, units of measure, and machine-independent
#' identifiers.
#'
#' @param x A vector.
#' @param value A character string specifying the namespace, or `NULL` to
#'   remove it.
#' @param ... Additional arguments for method compatibility with other classes.
#'
#' @return A character string representing the namespace attribute of a vector
#'   constructed with [defined()]. Returns the updated object (in setter forms).
#'
#' @examples
#' # Define a vector with a namespace
#' x <- defined("Q42", namespace = c(wd = "https://www.wikidata.org/wiki/"))
#'
#' # Get the namespace
#' var_namespace(x)
#' get_variable_namespaces(x)
#'
#' # Set the namespace
#' var_namespace(x) <- "https://example.org/ns/"
#'
#' # Remove the namespace
#' var_namespace(x) <- NULL
#'
#' # Use lower-level helpers (not typically used directly)
#' namespace_attribute(x)
#' namespace_attribute(x) <- "https://example.org/custom/"
#'
#' @family defined metadata methods and functions
#' @rdname var_namespace
#' @export

var_namespace <- function(x, ...) {
  # rlang::check_dots_used()
  UseMethod("var_namespace")
}

#' @export
var_namespace.default <- function(x, ...) {
  attr(x, "namespace", exact = TRUE)
}

#' @rdname var_namespace
#' @export
`var_namespace<-` <- function(x, value) {
  UseMethod("var_namespace<-")
}

#' @export
`var_namespace<-.default` <- function(x, value) {
  namespace_attribute(x) <- value
  x
}

#' @rdname var_namespace
#' @export
get_variable_namespaces <- var_namespace


#' @rdname var_namespace
#' @export
namespace_attribute <- function(x) {
  attr(x, "namespace", exact = TRUE)
}


#' @rdname var_namespace
#' @export
get_namespace_attribute <- function(x) {
  namespace_attribute(x)
}


#' @rdname var_namespace
#' @export
set_namespace_attribute <- function(x, value) {
  if ((!is.character(value) && !is.null(value)) || length(value) > 1) {
    stop(
      "`namespace` should be a single character string or NULL",
      call. = FALSE,
      domain = "R-dataset"
    )
  }
  attr(x, "namespace") <- value
  x
}


#' @rdname var_namespace
#' @export
`namespace_attribute<-` <- set_namespace_attribute
#' Get or Set a Unit of Measure
#'
#' Adds or retrieves a unit of measure (UoM) attribute to a vector. Units
#' provide semantic meaning for numeric or character data — such as currency,
#' weight, or time — helping prevent incorrect operations like merging values
#' measured in incompatible units.
#'
#' @param x A vector.
#' @param value A character string specifying the unit of measure, or `NULL` to
#'   remove the unit.
#' @param ... Further arguments for method extensions.
#'
#' @details The `"unit"` attribute stores a machine-readable representation of a
#' unit of measure (e.g., `"kg"`, `"USD"`, `"days"`). This is useful when
#' working with linked open data or when combining data from multiple sources
#' where silent mismatches in units could cause errors.
#'
#' For full integration with semantic metadata (e.g., labels, concepts,
#' namespaces), use [defined()] vectors or [dataset_df()] objects.
#'
#' `get_variable_units()` is an alias for `var_unit()`.
#'
#' See `vignette("defined", package = "dataset")` for end-to-end examples
#' involving semantic enrichment.
#'
#' @return
#' - `var_unit(x)` returns the `"unit"` attribute as a character string.
#' - `var_unit(x) <- value` sets, updates, or removes the unit and returns
#' the modified vector invisibly.
#'
#' @examples
#' # Retrieve the unit of measure (if defined)
#' var_unit(orange_df$circumference)
#'
#' # Regular data.frame columns have no unit by default
#' var_unit(mtcars$wt)
#'
#' # Add a unit to a column
#' var_unit(mtcars$wt) <- "1000 lbs"
#'
#' # Remove the unit
#' var_unit(mtcars$wt) <- NULL
#'
#' @family defined metadata methods and functions
#' @export
var_unit <- function(x, ...) {
  # rlang::check_dots_used()
  UseMethod("var_unit")
}

#' @export
var_unit.default <- function(x, ...) {
  attr(x, "unit", exact = TRUE)
}

#' @rdname var_unit
#'
#' @description
#' The `var_unit<-` assignment method sets, updates, or removes the `"unit"`
#' attribute of a vector. This can be used with `defined()` vectors or base
#' vectors to ensure consistent semantic annotation.
#'
#' @param value A character string defining the unit of measure, or `NULL` to
#'   remove the unit.
#'
#' @return
#' The modified object `x`, returned invisibly with the updated `"unit"`
#' attribute.
#'
#' @export
`var_unit<-` <- function(x, value) {
  UseMethod("var_unit<-")
}


#' @rdname var_unit
#' @export
`var_unit<-.default` <- function(x, value) {
  unit_attribute(x) <- value
  x
}


#' @rdname var_unit
#' @export
get_variable_units <- var_unit



#' @rdname var_unit
#'
#' @description
#' `unit_attribute()` is a low-level helper to directly access the `"unit"`
#' attribute of a vector, without applying fallback logic. It is mainly used
#' internally.
#'
#' @return
#' The `"unit"` attribute of the object `x`, or `NULL` if not set.
#'
#' @export
unit_attribute <- function(x) {
  attr(x, "unit", exact = TRUE)
}

#' @rdname var_unit
#'
#' @description
#' `get_unit_attribute()` is an alias for `unit_attribute()`, included for naming
#' consistency in codebases that distinguish getter/setter patterns.
#'
#' @export
get_unit_attribute <- function(x) {
  unit_attribute(x)
}


#' @rdname var_unit
#'
#' @description
#' `set_unit_attribute()` is the low-level assignment function that sets or
#' removes the `"unit"` attribute of an object. Used internally by
#' `unit_attribute<-`.
#'
#' @param value A single character string or `NULL`. If not of length one, an
#'   error is thrown.
#'
#' @return The object `x` with updated `"unit"` attribute.
#'
#' @export
set_unit_attribute <- function(x, value) {
  if ((!is.character(value) && !is.null(value)) || length(value) > 1) {
    stop(
      "`unit` should be a single character string or NULL",
      call. = FALSE,
      domain = "R-dataset"
    )
  }
  attr(x, "unit") <- value
  x
}

#' @rdname var_unit
#' @export
`unit_attribute<-` <- set_unit_attribute
#' Convert to XML Schema Definition (XSD) Types
#'
#' Converts R vectors, data frames, and `dataset_df` objects to
#' [XML Schema Definition (XSD)](https://www.w3.org/TR/xmlschema11-2/)
#' compatible string representations such as `xsd:decimal`, `xsd:boolean`,
#' `xsd:date`, and `xsd:dateTime`.
#'
#' This is primarily used for generating RDF-compatible typed literals.
#'
#' @details
#' - For **vectors**, returns a character vector of typed literals.
#' - For **data frames** or tibbles, returns a data frame with the same
#'   structure but with all values converted to XSD strings.
#' - For `dataset_df` objects, behaves like the data frame method but
#'   preserves dataset-level attributes.
#'
#' @param x An object (vector, data frame, tibble, or `dataset_df`).
#' @param idcol Column name or position to use as row (observation) identifier.
#'   If `NULL`, row names are used.
#' @param shortform Logical. If `TRUE` (default), datatypes are abbreviated with
#'   the `xsd:` prefix (e.g. `"42"^^<xsd:integer>`). If `FALSE`, datatypes are
#'   expanded to full URIs (e.g.
#'   `"42"^^<http://www.w3.org/2001/XMLSchema#integer>`).
#' @param ... Additional arguments passed to methods.
#'
#' @return A character vector or data frame with values serialized as
#' XSD-compatible RDF literals.
#'
#' @examples
#' # Simple data frame with mixed types
#' df <- data.frame(
#'   id     = 1:2,
#'   value  = c(3.14, 2.71),
#'   active = c(TRUE, FALSE),
#'   date   = as.Date(c("2020-01-01", "2020-12-31"))
#' )
#'
#' # Short vs long-form URI:
#' xsd_convert(120L, shortform = TRUE)
#' xsd_convert(121L, shortform = FALSE)
#'
#' @section Class-specific examples:
#' ```r
#' xsd_convert(42L)                   # integer -> xsd:integer
#' xsd_convert(c(TRUE, FALSE, NA))    # logical -> xsd:boolean
#' xsd_convert(Sys.Date())            # Date -> xsd:date
#' xsd_convert(Sys.time())            # POSIXct -> xsd:dateTime
#' xsd_convert(factor("apple"))       # factor -> xsd:string
#' xsd_convert(c("apple", "banana"))  # character -> xsd:string
#' ```
#' @family RDF and linked data helpers
#' @export

xsd_convert <- function(x, idcol = NULL, shortform = TRUE, ...) {
  UseMethod("xsd_convert", x)
}


#' @keywords internal
get_type <- function(t, shortform = TRUE) {
  base_type <- if (any(class(t) %in% c("numeric", "double"))) {
    "decimal"
  } else if (any(class(t) == "integer")) {
    "integer"
  } else if (any(class(t) %in% c("character", "factor"))) {
    "string"
  } else if (any(class(t) == "logical")) {
    "boolean"
  } else if (any(class(t) == "Date")) {
    "date"
  } else if (any(class(t) == "POSIXct")) {
    "dateTime"
  } else if (any(class(t) == "difftime")) {
    "duration"
  } else {
    "string"
  }

  xsd_uri(base_type, shortform = shortform)
}

#' @rdname xsd_convert
#' @exportS3Method
xsd_convert.haven_labelled_defined <- function(x, idcol = NULL,
                                               shortform = TRUE, ...) {
  type <- get_type(x, shortform)

  if (grepl("decimal$", type)) {
    return(xsd_convert(as_numeric(x), shortform = shortform, ...))
  }
  if (grepl("integer$", type)) {
    return(xsd_convert(as_numeric(x), shortform = shortform, ...))
  }
  if (grepl("string$", type)) {
    return(xsd_convert(as_character(x), shortform = shortform, ...))
  }
  if (grepl("boolean$", type)) {
    return(xsd_convert(as.logical(as_numeric(x)), shortform = shortform, ...))
  }

  stop("Unsupported haven_labelled_defined type: ", paste(class(x), collapse = ", "))
}

#' @rdname xsd_convert
#' @exportS3Method
xsd_convert.data.frame <- function(x, idcol = NULL, shortform = TRUE, ...) {
  # Identify ID column (or default to row names)
  if (!is.null(idcol)) {
    id_idx <- idcol_find(x, idcol)
    ids <- as.character(x[[id_idx]])
    id_name <- names(x)[id_idx]
  } else {
    ids <- row.names(x)
    id_name <- ".rowid"
  }

  convert_cols <- setdiff(
    seq_along(x),
    if (!is.null(idcol)) id_idx else integer(0)
  )

  # Apply xsd_convert to all non-ID columns, forwarding shortform + ...
  xsd_list <- lapply(
    convert_cols,
    function(c) xsd_convert(x[[c]], shortform = shortform, ...)
  )
  names(xsd_list) <- names(x)[convert_cols]

  # Assemble result: ID column first, then converted columns
  result <- c(
    setNames(list(ids), id_name),
    xsd_list
  )

  as.data.frame(result, stringsAsFactors = FALSE)
}


#' @rdname xsd_convert
#' @exportS3Method
xsd_convert.dataset_df <- function(x, idcol = "rowid",
                                   shortform = TRUE, ...) {
  NextMethod("xsd_convert", shortform = shortform, ...)
}

#' @rdname xsd_convert
#' @exportS3Method
xsd_convert.tbl_df <- function(x, idcol = NULL, shortform = TRUE, ...) {
  if (!inherits(x, "data.frame")) {
    stop("xsd_convert.tbl_df: input must be a data frame or tibble.")
  }
  NextMethod("xsd_convert", shortform = shortform, ...)
}

#' @rdname xsd_convert
#' @exportS3Method
xsd_convert.character <- function(x, idcol = NULL,
                                  shortform = TRUE, ...) {
  var_type <- xsd_uri("string", shortform)

  if (length(x) == 0) {
    return(paste0('""^^<', var_type, ">"))
  }

  ifelse(is.na(x),
    NA_character_,
    paste0('"', x, '"^^<', var_type, ">")
  )
}


#' @rdname xsd_convert
#' @exportS3Method
xsd_convert.numeric <- function(x, idcol = NULL,
                                shortform = TRUE, ...) {
  var_type <- xsd_uri("decimal", shortform)
  if (length(x) == 0) {
    return(paste0('""^^<', var_type, ">"))
  }

  formatted <- ifelse(is.na(x), NA_character_, {
    str <- format(x, scientific = FALSE, trim = TRUE, justify = "none")
    sub("\\.0$", "", str)
  })

  ifelse(is.na(formatted),
    NA_character_,
    paste0('"', formatted, '"^^<', var_type, ">")
  )
}

#' @rdname xsd_convert
#' @exportS3Method
xsd_convert.integer <- function(x, idcol = NULL, shortform = TRUE, ...) {
  var_type <- xsd_uri("integer", shortform)

  if (length(x) == 0) {
    return(paste0('""^^<', var_type, ">"))
  }

  ifelse(is.na(x),
    NA_character_,
    paste0('"', as.character(x), '"^^<', var_type, ">")
  )
}


#' @rdname xsd_convert
#' @exportS3Method
xsd_convert.logical <- function(x, idcol = NULL, shortform = TRUE, ...) {
  var_type <- xsd_uri("boolean", shortform)

  if (length(x) == 0) {
    return(paste0('""^^<', var_type, ">"))
  }

  ifelse(
    is.na(x),
    NA_character_,
    paste0('"', tolower(as.character(x)), '"^^<', var_type, ">")
  )
}



#' @rdname xsd_convert
#' @exportS3Method
xsd_convert.factor <- function(x, idcol = NULL, shortform = TRUE, ...) {
  args <- list(...)
  codelist <- args$codelist %||% NULL

  if (length(x) == 0) {
    return(paste0('""^^<', xsd_uri("string", shortform), ">"))
  }

  if (is.null(codelist)) {
    var_type <- xsd_uri("string", shortform)
    ifelse(
      is.na(x),
      NA_character_,
      paste0('"', as.character(x), '"^^<', var_type, ">")
    )
  } else {
    ifelse(
      is.na(x),
      NA_character_,
      paste0(codelist, ":", as.character(x))
    )
  }
}


#' @rdname xsd_convert
#' @exportS3Method
xsd_convert.POSIXct <- function(x, idcol = NULL, shortform = TRUE, ...) {
  var_type <- xsd_uri("dateTime", shortform)

  if (length(x) == 0) {
    return(paste0('""^^<', var_type, ">"))
  }

  time_string <- strftime(x, format = "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")

  ifelse(
    is.na(x),
    NA_character_,
    paste0('"', time_string, '"^^<', var_type, ">")
  )
}

#' @rdname xsd_convert
#' @exportS3Method
xsd_convert.Date <- function(x, idcol = NULL, shortform = TRUE, ...) {
  var_type <- xsd_uri("date", shortform)

  if (length(x) == 0) {
    return(paste0('""^^<', var_type, ">"))
  }

  date_str <- format(x, format = "%Y-%m-%d")

  ifelse(
    is.na(x),
    NA_character_,
    paste0('"', date_str, '"^^<', var_type, ">")
  )
}


#' @rdname xsd_convert
#' @exportS3Method
xsd_convert.difftime <- function(x, idcol = NULL, shortform = TRUE, ...) {
  var_type <- xsd_uri("duration", shortform)

  if (length(x) == 0) {
    return(paste0('""^^<', var_type, ">"))
  }

  seconds <- unclass(x)
  unit <- attr(x, "units")

  multiplier <- switch(unit,
    "secs" = 1,
    "mins" = 60,
    "hours" = 3600,
    "days" = 86400,
    stop("Unsupported difftime unit: ", unit)
  )
  seconds <- seconds * multiplier

  to_iso8601 <- function(s) {
    if (is.na(s)) {
      return(NA_character_)
    }
    h <- floor(s / 3600)
    m <- floor((s %% 3600) / 60)
    sec <- round(s %% 60)
    paste0(
      "PT",
      if (h > 0) paste0(h, "H") else "",
      if (m > 0) paste0(m, "M") else "",
      if (sec > 0 || (h == 0 && m == 0)) paste0(sec, "S") else ""
    )
  }

  iso_strs <- vapply(seconds, to_iso8601, character(1))

  ifelse(
    is.na(seconds),
    NA_character_,
    paste0('"', iso_strs, '"^^<', var_type, ">")
  )
}

#' @keywords internal
xsd_uri <- function(type, shortform = TRUE) {
  base <- "http://www.w3.org/2001/XMLSchema#"
  if (shortform) {
    paste0("xsd:", type)
  } else {
    paste0(base, type)
  }
}
